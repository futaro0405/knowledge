# 部分的プリレンダリング
これまで、静的レンダリングと動的レンダリング、そしてデータに依存する動的コンテンツのストリーミング方法について学んできました。  
この章では、**部分的プリレンダリング（PPR）**を使用して、同じルート内で静的レンダリング、動的レンダリング、ストリーミングを組み合わせる方法を学びましょう。  

部分的プリレンダリングは、Next.js 14で導入された実験的な機能です。  
この機能の安定性が進むにつれて、このページの内容が更新される可能性があります。  

この章では... 以下のトピックを扱います：  

1. 部分的プリレンダリングとは何か
2. 部分的プリレンダリングがどのように機能するか

これらのトピックを通じて、Next.jsの新しいレンダリングモデルについて理解を深めていきます。  

# 静的ルートvs動的ルート
今日の多くのウェブアプリでは、**アプリケーション全体**または**特定のルート**に対して、静的レンダリングと動的レンダリングのどちらかを選択します。  
Next.jsでは、ルート内で[動的関数](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-functions)（データベースへのクエリなど）を呼び出すと、そのルート全体が動的になります。  

しかし、ほとんどのルートは完全に静的または動的ではありません。  
例えば、[ecommerce site](https://partialprerendering.com/)を考えてみましょう。  
商品情報ページの大部分を静的にレンダリングしたいかもしれませんが、ユーザーのカートやおすすめ商品は動的にフェッチしたいかもしれません。  
これにより、ユーザーにパーソナライズされたコンテンツを表示できます。  

ダッシュボードページに戻ると、どのコンポーネントを静的、どのコンポーネントを動的と考えますか？  

準備ができたら、下のボタンをクリックしてダッシュボードルートをどのように分割するかを確認してください。  

![[Pasted image 20241012133318.png]]

- `<SideNav>`コンポーネントはデータに依存せず、ユーザーに対してパーソナライズされていないため、**静的**にすることができます。
- `<Page>`内のコンポーネントは頻繁に変更されるデータに依存し、ユーザーに対してパーソナライズされるため、**動的**にすることができます。

# 部分的プリレンダリングとは何か？

Next.js 14では、**部分的プリレンダリング**の実験的バージョンが導入されました。  
これは、同一ルート内で静的レンダリングと動的レンダリングの利点を組み合わせることができる新しいレンダリングモデルです。  
例えば：

![[Pasted image 20241012134000.png]]

ユーザーがルートにアクセスした時：

1. ナビゲーションバーと商品情報を含む静的なルートシェルが提供され、高速な初期ロードが保証されます。
2. このシェルには、カートやおすすめ商品などの動的コンテンツが非同期的に読み込まれる「穴」が残されています。
3. 非同期の穴は並行してストリーミングされ、ページの全体的な読み込み時間が短縮されます。

この方法により、静的コンテンツの高速な初期表示と、動的コンテンツのパーソナライズされた体験を両立させることができます。  

# 部分的プリレンダリングはどのように機能するか？
部分的プリレンダリングは、Reactの [Suspense](https://react.dev/reference/react/Suspense)（前章で学びました）を使用して、アプリケーションの一部の描画を特定の条件が満たされるまで（例：データが読み込まれるまで）延期します。  

Suspenseのフォールバックは、静的コンテンツと共に初期HTMLファイルに埋め込まれます。  
ビルド時（または再検証時）に、静的コンテンツが**プリレンダリング**され、静的なシェルが作成されます。  
動的コンテンツの描画は、ユーザーがルートをリクエストするまで**延期**されます。  

コンポーネントをSuspenseでラップしてもそのコンポーネント自体が動的になるわけではありません。  
むしろ、Suspenseは静的コードと動的コードの境界として使用されます。  

では、ダッシュボードルートでPPRをどのように実装できるか見てみましょう。  

# 部分的プリレンダリングの実装
Next.jsアプリでPPRを有効にするには、`next.config.mjs`ファイルに`ppr`オプションを追加します：  

**next.config.mjs**
```javascript
/** @type {import('next').NextConfig} */
 
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
};
 
export default nextConfig;
```

`'incremental'`の値を使用すると、特定のルートに対してPPRを採用できます。  

次に、ダッシュボードレイアウトに`experimental_ppr`セグメント設定オプションを追加します：  

**/app/dashboard/layout.tsx**
```javascript
import SideNav from '@/app/ui/dashboard/sidenav';
 
export const experimental_ppr = true;
 
// ...
```

これで完了です。開発環境ではアプリケーションに違いが見られない可能性がありますが、本番環境ではパフォーマンスの向上が確認できるはずです。  
Next.jsはルートの静的な部分をプリレンダリングし、動的な部分をユーザーがリクエストするまで延期します。  

部分的プリレンダリングの素晴らしい点は、使用するためにコードを変更する必要がないことです。  
ルートの動的な部分をSuspenseでラップしている限り、Next.jsはルートのどの部分が静的で、どの部分が動的かを認識します。  

PPRは、静的サイトと動的レンダリングの利点を組み合わせた、 [Webアプリケーションのデフォルトのレンダリングモデルになる](https://vercel.com/blog/partial-prerendering-with-next-js-creating-a-new-default-rendering-model)可能性があると考えています。  
ただし、まだ実験的な段階です。将来的には安定化させ、Next.jsでのビルドのデフォルトの方法にすることを目指しています。  

# まとめ
アプリケーションのデータ取得を最適化するために、以下のことを行いました：  

1. アプリケーションコードと同じリージョンにデータベースを作成し、サーバーとデータベース間のレイテンシーを削減しました。
2. React Server Componentsでサーバー上のデータを取得しました。これにより、高コストのデータ取得とロジックをサーバー上に保持し、クライアントサイドのJavaScriptバンドルを削減し、データベースのシークレットがクライアントに露出するのを防ぎました。
3. SQLを使用して必要なデータのみを取得し、各リクエストで転送されるデータ量と、メモリ内でデータを変換するために必要なJavaScriptの量を削減しました。
4. 適切な場合には、JavaScriptを使用してデータ取得を並列化しました。
5. ストリーミングを実装し、遅いデータリクエストがページ全体をブロックするのを防ぎ、すべてが読み込まれるのを待たずにユーザーがUIとの対話を開始できるようにしました。
6. データ取得を必要とするコンポーネントに移動し、ルートのどの部分を動的にすべきかを分離しました。

次の章では、データ取得時に実装が必要となる可能性がある2つの一般的なパターン、検索とページネーションについて見ていきます。  

