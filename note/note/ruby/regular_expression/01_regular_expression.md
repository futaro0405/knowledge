# 正規表現とは
パターンを指定して、文字列を効率的に検索・置換するためのミニ言語
# Rubyにおける正規表現オブジェクト
正規表現オブジェクトはスラッシュでパターンを囲んで作成する（正規表現リテラル）。

```
r = /\d{3}-\d{4}/
r.class #=> Regexp
```

文字列と正規表現のマッチを試みる方法として`=~`を使う。
`=~`でマッチした場合文字列中の最初にマッチした位置（0以上の数値）が返り、マッチしなければnilが返る。

```
'123-4567' =~ /\d{3}-\d{4}/ #=> 0
'hello' =~ /\d{3}-\d{4}/ #=> nil
```
条件分岐でもよく使われる。
```
if '123-4567' =~ /\d{3}-\d{4}/
  puts 'マッチしました'
else
  puts 'マッチしませんでした'
end
```

`!~`を使うとマッチしなかったときにtrue、マッチしたときにfalseを返す、
```
'hello' !~ /\d{3}-\d{4}/ #=>true
'123-4567' !~ /\d{3}-\d{4}/ #=> false
```

# 正規表現のキャプチャを利用する
以下の文から文字列を正規表現で抜き出す。
正規表現のキャプチャ機能を利用する。
()を使って抜き出したい部分をする。

```
私の誕生日は1997年7月17日です。

(\d+)年(\d+)月(\d+)日
```

Rubyで上記のようにキャプチャ機能を使う場合は`match`メソッドを使う。
文字列とマッチするとMatchDataオブジェクトが返る。
マッチしない場合はnilが返る。

```
text = '私の誕生日は1997年7月17日です。'
m = /(\d+) 年 (\d+) 月 (\d+) 日 /.match(text)
m[1] #=>1997
a[2] #=>7
a[3] #=>17
```

この性能を使って条件分岐の中で真偽値の判定とローカル変数への代入を同時に行う。

```
text = '私の誕生日は1997年7月17日です。'
if m = /(\d+) 年 (\d+) 月 (\d+) 日 /.match(text)
  # マッチしたときの処理
else
  # マッチしないときの処理
end
```

MatchDataは[]を使って正規表現の処理結果を配列と同じような方法で取得できる。

```
text = '私の誕生日は1997年7月17日です。'
m = /(\d+) 年 (\d+) 月 (\d+) 日 /.match(text)

# マッチした部分全体を取得する
m[0] #=> "1997年7月17日"

# キャプチャの1番目を取得する
m[1] #=> "1997"

# キャプチャの2番目から2個取得する
m[2, 2] #=> ["7", "17"]

# 最後のキャプチャを取得する
m[-1] #=> "17"

# Rangeを使って取得する
m[1..3] #=> ["1997", "7", "17"]
```

`match`メソッドはStringクラスとRegexpクラスの両方に定義されているため、文字列と正規表現オブジェクトを入れ替えても同じように動作する。

```
m = text.match(/(\d+) 年 (\d+) 月 (\d+) 日 /)
```

# キャプチャに名前をつける
キャプチャには`(?<name>)`というメタ文字を使って名前を付けることができる。
連番ではなく名前でキャプチャの結果を取得することができるため、何番目が何の値かを気にする必要がない。
```
(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日
```

```
text = '私の誕生日は1997年7月17日です。'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日 /.match(text)

# シンボルで名前を指定してキャプチャの結果を取得する
m[:year] #=>1997
m[:month] #=>7
m[:day] #=>17

# 文字列で指定も可能
m['year'] #=>1997
```

左辺に文字列を置き、`=~`演算子を使うことでキャプチャの名前がそのままローカル変数に割り当てられる。
ただし、右辺と左辺を逆にすると機能しない。
また、正規表現オブジェクトを一旦変数に入れた場合も同様に機能しない。
```
text = '私の誕生日は1997年7月17日です。'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日 /.match(text) =~ text
  puts "#{year}/#{month}/#{day}"
end
# => "1997/7/17"
```

# 組み込み変数でマッチの結果を取得する
Rubyには`$`で始まる特殊な変数（__組み込み変数__）が存在する。
`=~`演算子や`match`メソッドを使うといくつかの組み込み変数にマッチした結果が代入される。

```
text = '私の誕生日は1997年7月17日です。'

text =~ /(\d+)年(\d+)月(\d+)日/

# MatchDataオブジェクトを取得する
$~
#=> #<MatchData "1997年7月17日" 1:"1997" 2:"7" 3:"17">

# マッチした部分全体を取得する
$&
#=> "1997年7月17日"

# 1番目～3番目のキャプチャを取得する
$1 #=> "1997"
$2 #=> "7"
$3 #=> "17"

# 最後のキャプチャの文字列を取得する
$+
#=> "17"
```

# 正規表現と組み合わせるStringクラスのメソッド
Stringクラスには正規表現と組み合わせると便利なメソッドがいくつか用意されている。

- `scan`
- `[]`,`slice`,`slice!`
- `split`
- `gsub`,`gsub!`

## `scan`メソッド
`scan`メソッドは引数で渡した正規表現にマッチした部分を配列に入れて返す。

```
'123 456 789'.scan(/\d+/)
# => ["123","456","789"]
```

正規表現に()があると、キャプチャされた部分が配列になって返ってくる。

```
'1997年7月17日 2022年12月31日'.scan(/(\d+)年(\d+)月(\d+)日/)
# => [["1997","7","17"],["2021","12","31"]]
```

グループ化したいがキャプチャはしたくない（マッチした文字列全体を取得したい）場合は、`(?:)`というメタ文字を使う。

```
'1997年7月17日 2022年12月31日'.scan(/(?:\d+)年(?:\d+)月(?:\d+)日/)
# => ["1997年7月17日","2021年12月31日"]

# 説明のためにやったが以下の記述が簡潔な正規表現
'1997年7月17日 2022年12月31日'.scan(/\d+ 年 \d+ 月 \d+ 日 /)
# => ["1997年7月17日","2021年12月31日"]
```

## `[]`,`slice`,`slice!`
`[]`に正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出してくれます。
マッチした部分が複数ある場合は、最初にマッチした文字列が返ります。

```
text = '郵便番号は123-4567です'
text[/\d{3}-\d{4}/] #=> "123-4567"
```

キャプチャを使うと第2引数で何番目のキャプチャを取得するかを指定できる。

```
text = '誕生日は1997年7月17日です'

# 第2引数がないとマッチした部分全体が返る
text[/\d+ 年 \d+ 月 \d+ 日 /] #=> "1997年7月17日"

# 第2引数を指定して3番目のキャプチャをを取得する
text[/\d+ 年 \d+ 月 \d+ 日 /, 3] #=> "17"
```

名前付きキャプチャであれば名前で指定することもできる。

```
# シンボルでキャプチャの名前を指定
text[/(?<yaer>\d+) 年 (?<month>\d+) 月 (?<day>\d+) 日 /, :day] #=> "17"

# 文字列でキャプチャの名前を指定
text[/(?<yaer>\d+) 年 (?<month>\d+) 月 (?<day>\d+) 日 /, 'day'] #=> "17"
```

`slice`メソッドは`[]`のエイリアスメソッドです。

```
text = '郵便番号は123-4567です'
text.slice(/\d{3}-\d{4}/) #=> "123-4567"
```

`slice!`メソッドを使用するとマッチした部分が文字列から破壊的に取り除かれます。

```
text = '郵便番号は123-4567です'
text.slice!(/\d{3}-\d{4}/) #=> "123-4567"
text # => '郵便番号はです'
```

## `split`メソッド
`split`メソッドに正規表現を渡すと、マッチした文字列を区切り文字にして文字列を分解し、配列として返します。

```
text = '123,456-789'

# 文字列で区切り文字を指定する
text.split(',') #=> ["123","456-789"]

# 正規表現を使ってカンマまたはハイフンを区切り文字に指定する
text.split(/,|-/) #=> ["123","456","789"]
```

## `gsub`メソッド,`gsub!`メソッド
`gsub`メソッドを使うと、第1引数の正規表現にマッチした文字列を第2引数の文字列で置換します。

```
text = '123,456-789'

# 第1引数に文字列を渡すと文字列を渡すと完全一致する文字列を第2引数で置き換える
text.gsub(',',':') #=> "123:456-789"

# 正規表現を渡すと、マッチした部分を第2引数で置き換える
text.gsub(/,|-/, ':') #=> "123:456:789"
```

第2引数にハッシュを渡して変換のルールを指定することもできます。

```
text = '123,456-789'

hash = {','=>':','-'=>'/'}
text.gsub(/,|-/, hash) #=> "123:456/789"
```

第2引数を渡す代わりにブロックの戻り値で置き換える文字列を指定することも可能です。

```
text = '123,456-789'

# カンマはコロンに、それ以外はスラッシュに
text.gsub(/,|-/){|matched| matched==','?':' : '/'} #=> "123:456/789"
```

`gsub!`メソッドは文字列の内容を破壊的に置換します。

```
text = '123,456-789'
text.gsub!(/,|-/, ':')
text #=> "123:456:789"
```

`gsub`メソッドや`gsub!`メソッドはキャプチャと組み合わせて文字列を置換することができます。
キャプチャを使う場合は第2引数に文字列で指定する方法と、ブロックと組み込み文字を使う方法の2種類あります。
第2引数に文字列で指定する場合は`\1`や`\2`のようにしてキャプチャした文字列を連番で参照できます。
（このとき、有効な連番は`\1`から`\9`までです。）

```
text = '誕生日は1997年7月17日です'
text.gsub(/(\d+) 年 (\d+) 月 (\d+) 日 /, '\1-\2-\3')
# => "誕生日は 1997-7-17 です"
```

ただし、`\1`や`\2`を第2引数に指定する場合は、文字列をシングルクオートで囲むか、ダブルクオートで囲むかで書き方が変わるため注意が必要です。

```
# ダブルクオートで囲む場合は、\\1のようにバックスラッシュを2つ重ねる
text.gsub(/(\d+) 年 (\d+) 月 (\d+) 日 /, "\\1-\\2-\\3")
```

バックスラッシュをエスケープしようとすると第2引数に指定する文字列がかなり複雑化する場合があります。
この問題を避けるために`gsub`メソッド、`gsub!`メソッドでは第2引数の代わりにブロックを使って文字列を置換できます。
ブロックの内部では組み込み変数を使ってキャプチャした文字列を参照できます。ブロックの戻り値が置換後の文字列になります。

```
text.gsub(/ (\d+) 年 (\d+) 月 (\d+) 日 /) do
  "#{$1}-#{$2}-{$3}"
end
# => "誕生日は1997-7-17です"
```

名前つきキャプチャを使う場合も第2引数に文字列で指定する方法とブロックを使う方法の2種類があります。
文字列で指定する場合は`\k<name>`(ダブルクオートで囲む場合は`\\k<name>`)のようにして参照します。

```
text = '誕生日は1997年7月17日です'
text.gsub(/(?<year>\d+) 年 (?<month>\d+) 月 (?<day>\d+) 日/ , '\k<year>-\k<month>-\k<day>')
# => "誕生日は1997-7-17です"
```

ブロックを使う場合は`$~`でMatchDataオブジェクトが参照できるため、キャプチャした文字列は`$~[:name]`のようにして参照します。

```
text.gsub(/(?<year>\d+) 年 (?<month>\d+) 月 (?<day>\d+) 日/) do
  "#{$~[:year]}-#{$~[:month]}-#{$~[:day]}"
end
# => "誕生日は1997-7-17です"
```

# 正規表現オブジェクトをもっと詳しく
## 正規表現オブジェクトを作成する様々な方法
正規表現オブジェクトを作成する方法のひとつに`Regexp.new`(`Regexp.compile`)の引数にパターンの文字列を渡す方法がある。
もうひとつは`%r`を使う方法（%記法）がある。

```
/http:\/\/example\.com/

Regexp.new('\d{3}-\d{4}')

%r!https://example\.com!
```

`//`や`%r`の中で`#{}`を使うと式の値を埋め込むことができる。

```
pattern = '\d{3}-\d{4}'

'123-4567' =~ /#{pattern} #=> 0
```

## `case`文で正規表現を使う
正規表現は`case`文の`when`節で使うことができる。
`case`節で指定した文字列が`when`節で指定した正規表現にマッチすると`when`節の処理が実行される。

```
text = '03-1234-5678'

case text
  when /^\d{3}-\d{4}$/
    puts '郵便番号です'
  when /^\d{4}\/\d{1,2}\/\d{1,2}$/
    puts '日付です'
  when /^\d+-\d+-\d+$/
    puts '電話番号です'
end
# => 電話番号です
```

## 正規表現オブジェクト作成時のオプション
正規表現オブジェクトの作成時にはいくつかのオプションを渡すことができる。

### `i`オプション
アルファベットの大文字と小文字の違いを無視してマッチする。

```
'HELLO' =~ /hello/i #=>0
'HELLO' =~ %r{hello}i #=>0
```

`Regexp.new`を使う場合は、`Regexp::IGNORECASE` という定数を渡す。

```
regexp = Regexp.new('hello', Regexp::IGNORECASE)
'HELLO' =~ regexp #=>0
```

### `m`オプション
任意の文字を表すドット(.)が改行文字にもマッチするようになる。

```
"Hello\nBye" =~ /Hello.Bye/ # => nil
"Hello\nBye" =~ /Hello.Bye/m # => 0
```

`Regexp.new`を使う場合は、`Regexp::MULTILINE` という定数を渡す。

```
regexp = Regexp.new('Hello.Bye', Regexp::MULTILINE)
'Hello\nBye' =~ regexp #=>0
```

### `x`オプション
空白文字（半角スペースや改行文字）が無視され、#を使って正規表現中にコメントがかける。

```
regexp = /
  \d{3} # 郵便番号の先頭3行
  - # 区切り文字のハイフン
  \d{4} # 郵便番号の先頭4行
/x

'123-4567' =~ reqexp # => 0
```

`Regexp.new`を使う場合は、`Regexp::EXTENDED` という定数を渡す。

```
pattern = <<'TEXT'
  \d{3} # 郵便番号の先頭3行
  - # 区切り文字のハイフン
  \d{4} # 郵便番号の先頭4行
TEXT

regexp = Regexp.new(pattern, Regexp::EXTENDED)

'123-4567' =~ reqexp # => 0
```

これらのオプションは同時に使うことができる。

```
"HELLO\nBYE" =~ /Hello.Bye/im #=> 0
```

`Regexp.new`を使う場合は、`|`で連結させる。

```
regexp = Regexp.new('Hello.Bye', Regexp::IGNORECASE | Regexp::MULTILINE)
'HELLO\nBYE' =~ regexp #=>0
```

## `Regexp.last_match`でマッチの結果を取得する
 `Regexp.last_match`メソッドを使うと組み込み変数のように、`=~`演算子などで最後にマッチした結果をMAatchDataオブジェクトとして取得できる。

```
text = '私の誕生日は1997年7月17日です'
text =~ /(\d+)年(\d+)月(\d+)日/
Regexp.last_match # => <MatchData "1997年7月17日" 1:"1997" 2:"7" 3:"17">
Regexp.last_match(0) # => "1997年7月17日"
Regexp.last_match(1) # => "1997"
Regexp.last_match(2) # => "7"
Regexp.last_match(3) # => "17"
Regexp.last_match(-1) # => "17"
```

## 組み込み変数を書き換えない`match?`メソッド
`match?`メソッドは文字列がマッチすれば、true、しなければfalse
ただし、マッチした場合でも内容を書き換えない。

```
/\d{3}-\d{4}/.match?('123-4567')
# => true

$~ # => nil
Regexp.last_match # => nil
```
