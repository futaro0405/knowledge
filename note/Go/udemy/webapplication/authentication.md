# Auth Packages Introduction
このビデオでは、認証に使用するライブラリについて説明します。

1. 現在の状況：
    - アプリにはユーザー認証がありません。
    - URLを知っている人なら誰でもすべてのノートを見ることができます。
    - 認証のテスト用に、多数のノートがアプリに追加されています。
2. 使用する最初のライブラリ：bcrypt
    - bcryptは適応型ハッシュアルゴリズムです。
    - ユーザーパスワードはこのアルゴリズムでハッシュ化され、データベースに保存されます。
    - ユーザーがサインインする際、新しいパスワードが再度ハッシュ化され、データベースに保存されているハッシュ化されたパスワードと比較されます。
3. 使用する2つ目のパッケージ：sessions
    - ユーザーのセッション情報を保存するために使用されます。
    - sessionsパッケージは多くの種類のバックエンドをサポートしています：
        - Redis
        - Memcached
        - MongoDB
        - PostgreSQL など

これらのライブラリを使用することで、アプリケーションにセキュアな認証システムを実装し、ユーザーごとのデータ保護を実現することができます。

# Login and Signup Pages

![[Pasted image 20241020105318.png]]

1. ユーザー認証の実装前に、サインアップとログイン用の簡単なフォームを作成します。
2. サインアップページの構成：
    - ユーザーのメールアドレス
    - パスワード
    - パスワード確認
3. ログインフォームの構成：
    - ユーザーのメールアドレス
    - パスワード

![[Pasted image 20241020105437.png]]

1. テンプレートの名前変更：
    - 「template/views」を「template/home」に変更
    - すべての参照を更新

![[Pasted image 20241020105703.png]]

1. サインアップフォームの新規テンプレート作成：
    - index.htmlから基本構造をコピー
    - テンプレート名を変更
    - 見出しを「Sign Up」に変更
    - フォームのアクションを「/signup」に設定
    - 入力フィールドを適切に設定（email, password, confirm password）

![[Pasted image 20241020121633.png]]

1. ログインページのテンプレート作成：
    - サインアップページからコードをコピー
    - 見出しを「Login」に変更
    - フォームのアクションを「/login」に設定
    - パスワード確認フィールドを削除

![[Pasted image 20241020121704.png]]

1. main.goにルートを追加：
    - "/login" → LoginPage
    - "/signup" → SignupPage

![[Pasted image 20241020121820.png]]

1. 新しいコントローラ（SessionController）の作成：
    - LoginPageハンドラとSignupPageハンドラを実装
    - これらのハンドラは単にHTMLページをレンダリング

![[Pasted image 20241020122058.png]]

1. アプリケーションのメインページにログインとサインアップボタンを追加
2. サーバーを再起動し、ブラウザでテスト：
    - localhost:8080にアクセス
    - ログインとサインアップボタンが表示されることを確認
    - 各ボタンをクリックし、対応するフォームが正しくレンダリングされることを確認

これらの手順により、基本的なログインとサインアップのユーザーインターフェースが実装されました。次のステップでは、これらのフォームに機能を追加し、実際の認証プロセスを実装することになります。

# User model and Signup functionality

![[Pasted image 20241020124537.png]]

1. まず、パスワードハッシュ化に役立つbcryptパッケージをインストールします。
2. 次に、ユーザーセッション管理のためのsessionsパッケージをインストールします。

![[Pasted image 20241020124712.png]]

1. ヘルパー関数を含む新しいディレクトリ「helpers」を作成します。
2. 「password_hashing.go」ファイルを作成し、パスワードのハッシュ化と照合のための2つの関数を実装します：
    - hashPassword: パスワードをハッシュ化
    - checkPasswordHash: パスワードとハッシュを比較

![[Pasted image 20241020124843.png]]

1. 「session.go」ファイルを作成し、セッション管理のユーティリティ関数を実装します：
    - SessionSet: ユーザーIDをセッションに保存
    - SessionGet: セッションからユーザーIDを取得
    - SessionClear: セッションからユーザーIDをクリア

![[Pasted image 20241020124955.png]]

1. 「models/user.go」にユーザーモデルを作成し、構造体を定義します。

![[Pasted image 20241020125125.png]]

1. セッション管理の関数を実装します。

![[Pasted image 20241020125343.png]]

1. main.goにログイン、サインアップ、ログアウトのルートを追加します。

![[Pasted image 20241020125503.png]]

1. SessionsControllerにハンドラ関数を実装します：
    - サインアップ: メールアドレスの重複チェック、パスワードの確認、ユーザー作成
    - ログイン、ログアウト（次のビデオで実装予定）

![[Pasted image 20241020125614.png]]

![[Pasted image 20241020154714.png]]

![[Pasted image 20241020154414.png]]

![[Pasted image 20241020154817.png]]

1. ユーザーモデルに関連する関数を実装：
    - CheckAvailability: メールアドレスの重複チェック
    - Create: 新規ユーザー作成（パスワードをハッシュ化して保存）

![[Pasted image 20241020154842.png]]

1. HTMLテンプレートにアラート表示用の要素を追加します。

これらの手順により、基本的な認証システムの骨格が実装されました。次のビデオでは、ログインとログアウト機能を完成させる予定です。

# Login and logout

![[Pasted image 20241020161636.png]]

![[Pasted image 20241020161653.png]]

1. アプリケーションに認証を追加するため、全てのAPIコールでセッションの存在を確認する必要があります。
2. この機能をミドルウェアに移動させます。ミドルウェアはリクエストとコントローラーの間に位置します。
3. 設計するミドルウェアの機能：
    - APIからセッション情報を読み取る
    - ユーザー詳細を取得する
    - ユーザーIDとメールアドレスをGinのコンテキストにセットする
4. これにより、コントローラーはログインユーザーのIDにアクセスでき、ユーザーIDの有無に基づいてログイン状態を判断できます。
5. コードの実装：
    - 「middleware」フォルダを作成
    - 「auth.go」ファイルを作成
6. カスタムミドルウェアの実装：
    - 「AuthenticateUser」関数を作成（戻り値の型はgin.HandlerFunc）
    - この関数内で、コンテキストを受け取る別の関数を返す
7. セッション情報の取得：
    - コンテキストからデフォルトセッションを取得
    - セッションから「ID」キーの値を取得（ログインまたはサインアップ時にセットしたもの）

- ユーザーモデルのインスタンスを作成します。
- `userPresent`という変数を作成し、初期値をtrueに設定します。
- セッションIDが存在しない場合、セッションがないことを意味するので`userPresent`をfalseに設定します。
- セッションが実際の有効なユーザーに属しているかを確認します：
    - `models.UserFind(sessionID)`を呼び出してユーザーオブジェクトを取得します。
- UserFind関数をユーザーモデルに実装します：
    - パラメータとしてIDを受け取り、ユーザーへのポインタを返します。
    - ユーザーのインスタンスを作成し、IDで検索クエリを実行します。
    - 最初の行を取得し、ユーザー変数のアドレスを返します。
- ミドルウェアに戻り、ユーザーが存在する場合の処理を行います：
    - ユーザーIDが0より大きい場合、ユーザーが存在すると判断します。
    - ユーザーが存在する場合、GinのコンテキストにユーザーIDとメールアドレスをセットします：
        - `c.Set("userID", user.ID)`
        - `c.Set("email", user.Email)`
- 関数の最後で`c.Next()`を呼び出し、次のミドルウェアに制御を渡します。

1. ミドルウェアチェーンの最後の場合、制御はコントローラーに移ります。
2. カスタムミドルウェアの準備ができましたが、まだチェーンに追加していません。
3. main.goファイルに移動し、ミドルウェアを追加します：
    - `r.Use(middleware.AuthenticateUser())` を追加します。
    - これだけで、カスタムミドルウェアがチェーンに追加されます。
4. セッション管理のために作成したヘルパー関数を使用します。sessionsパッケージ自体もミドルウェアです。
5. カスタムミドルウェア（AuthenticateUser）の前にセッションミドルウェアを追加する必要があります：
    - `store := memstore.NewStore([]byte("secret"))`でセッションストアを作成します。
    - `r.Use(sessions.Sessions("mysession", store))`でセッションミドルウェアを追加します。
6. これにより、セッションミドルウェアがカスタムミドルウェアの前に追加されます。
7. ルートハンドラ（"/"）でHTMLをレンダリングする際、ユーザーがログインしているかどうかを示す追加のキー"loggedIn"を渡します：
    - `c.GetUint64("userID")`を使用してコンテキストから直接この情報を取得できます。

この実装により、以下のことが可能になります：

- セッション管理の一貫した処理
- 各リクエストでのユーザー認証状態の確認
- ビューでのログイン状態の簡単な判断


- ユーザーIDが0より大きい場合、ユーザーはログインしていると判断します。
- indexページのテンプレートに移動します。ここにログインとサインアップのボタングループを追加しました。
- ユーザーのログイン状態に基づいてボタンの表示を切り替えます：
    - ログイン中の場合：ログアウトボタンを表示
    - ログインしていない場合：ログインとサインアップボタンを表示
- ログアウト（/logout）はPOST APIなので、ログアウトボタンを実装するために空のフォームを作成します。
- main.goに移動し、まだ実装していない2つのPOST API（/loginと/logout）を確認します。
- SessionsControllerに移動し、これらのハンドラ関数を実装します。
- まずログイン機能を実装します：
    - このハンドラはログインフォームが送信されたときに呼び出されます。
    - フォームからメールアドレスとパスワードを読み取ります（サインアップハンドラからコードをコピーできます）。
- メールアドレスとパスワードが一致するかチェックする関数を呼び出します：
    - models.UserCheck(email, password)という関数を想定します（まだ実装されていない）。

1. ユーザーモデルに移動し、UserCheck関数を実装します：
    - 引数としてemailとpasswordを受け取り、userを返します。
    - まず、与えられたメールアドレスでユーザーを検索します。
    - ユーザーが存在しない場合はnilを返します。
    - パスワードチェックには先に実装したcheckPasswordHash関数を使用します。
    - パスワードが一致すればユーザーを、一致しなければnilを返します。
2. コントローラーに戻り、ログイン処理を完成させます：
    - ユーザーが存在する場合、セッションを設定し、インデックスページにリダイレクトします。
    - ユーザーが見つからない場合、ログインページにアラートメッセージと共にリダイレクトします。
3. ログアウト機能を実装します：
    - セッションをクリアし、ログインページを表示します。
    - アラートメッセージ「ログアウトしました」を表示します。
4. ユーザーモデルのマイグレーションを追加します：
    - models/setup.goのDbMigrate関数に、ユーザーモデルのマイグレーションを追加します。
5. アプリケーションを実行し、MySQLコンソールでテーブルを確認します：
    - 実行前は「notes」テーブルのみでしたが、実行後は「notes」と「users」の2つのテーブルが存在します。
    - usersテーブルの構造がモデルで定義したものと一致することを確認します。
6. サーバーを起動し、ログイン機能をテストします：
    - 正しいメールアドレスとパスワードでログインすると、ホームページにリダイレクトされ、ログアウトボタンが表示されます。
    - ログアウトをクリックすると、ログインページに戻り、「ログアウトしました」というアラートが表示されます。
    - 間違ったパスワードでログインを試みると、ログインページに戻り、「メールアドレスまたはパスワードが一致しません」というアラートが表示されます。

これらの実装により、基本的なユーザー認証システム（ログイン、ログアウト、パスワード検証）が完成しました。また、データベースにユーザー情報を保存するためのテーブルも正しく作成されています。