# Auth Packages Introduction
このビデオでは、認証に使用するライブラリについて説明します。

1. 現在の状況：
    - アプリにはユーザー認証がありません。
    - URLを知っている人なら誰でもすべてのノートを見ることができます。
    - 認証のテスト用に、多数のノートがアプリに追加されています。
2. 使用する最初のライブラリ：bcrypt
    - bcryptは適応型ハッシュアルゴリズムです。
    - ユーザーパスワードはこのアルゴリズムでハッシュ化され、データベースに保存されます。
    - ユーザーがサインインする際、新しいパスワードが再度ハッシュ化され、データベースに保存されているハッシュ化されたパスワードと比較されます。
3. 使用する2つ目のパッケージ：sessions
    - ユーザーのセッション情報を保存するために使用されます。
    - sessionsパッケージは多くの種類のバックエンドをサポートしています：
        - Redis
        - Memcached
        - MongoDB
        - PostgreSQL など

これらのライブラリを使用することで、アプリケーションにセキュアな認証システムを実装し、ユーザーごとのデータ保護を実現することができます。

# Login and Signup Pages

![[Pasted image 20241020105318.png]]

1. ユーザー認証の実装前に、サインアップとログイン用の簡単なフォームを作成します。
2. サインアップページの構成：
    - ユーザーのメールアドレス
    - パスワード
    - パスワード確認
3. ログインフォームの構成：
    - ユーザーのメールアドレス
    - パスワード

![[Pasted image 20241020105437.png]]

1. テンプレートの名前変更：
    - 「template/views」を「template/home」に変更
    - すべての参照を更新

![[Pasted image 20241020105703.png]]

1. サインアップフォームの新規テンプレート作成：
    - index.htmlから基本構造をコピー
    - テンプレート名を変更
    - 見出しを「Sign Up」に変更
    - フォームのアクションを「/signup」に設定
    - 入力フィールドを適切に設定（email, password, confirm password）

![[Pasted image 20241020121633.png]]

1. ログインページのテンプレート作成：
    - サインアップページからコードをコピー
    - 見出しを「Login」に変更
    - フォームのアクションを「/login」に設定
    - パスワード確認フィールドを削除

![[Pasted image 20241020121704.png]]

1. main.goにルートを追加：
    - "/login" → LoginPage
    - "/signup" → SignupPage

![[Pasted image 20241020121820.png]]

1. 新しいコントローラ（SessionController）の作成：
    - LoginPageハンドラとSignupPageハンドラを実装
    - これらのハンドラは単にHTMLページをレンダリング

![[Pasted image 20241020122058.png]]

1. アプリケーションのメインページにログインとサインアップボタンを追加
2. サーバーを再起動し、ブラウザでテスト：
    - localhost:8080にアクセス
    - ログインとサインアップボタンが表示されることを確認
    - 各ボタンをクリックし、対応するフォームが正しくレンダリングされることを確認

これらの手順により、基本的なログインとサインアップのユーザーインターフェースが実装されました。次のステップでは、これらのフォームに機能を追加し、実際の認証プロセスを実装することになります。

# User model and Signup functionality

![[Pasted image 20241020124537.png]]

1. まず、パスワードハッシュ化に役立つbcryptパッケージをインストールします。
2. 次に、ユーザーセッション管理のためのsessionsパッケージをインストールします。

![[Pasted image 20241020124712.png]]

1. ヘルパー関数を含む新しいディレクトリ「helpers」を作成します。
2. 「password_hashing.go」ファイルを作成し、パスワードのハッシュ化と照合のための2つの関数を実装します：
    - hashPassword: パスワードをハッシュ化
    - checkPasswordHash: パスワードとハッシュを比較

![[Pasted image 20241020124843.png]]

1. 「session.go」ファイルを作成し、セッション管理のユーティリティ関数を実装します：
    - SessionSet: ユーザーIDをセッションに保存
    - SessionGet: セッションからユーザーIDを取得
    - SessionClear: セッションからユーザーIDをクリア

![[Pasted image 20241020124955.png]]

1. 「models/user.go」にユーザーモデルを作成し、構造体を定義します。

![[Pasted image 20241020125125.png]]

1. セッション管理の関数を実装します。

![[Pasted image 20241020125343.png]]

1. main.goにログイン、サインアップ、ログアウトのルートを追加します。

![[Pasted image 20241020125503.png]]

1. SessionsControllerにハンドラ関数を実装します：
    - サインアップ: メールアドレスの重複チェック、パスワードの確認、ユーザー作成
    - ログイン、ログアウト（次のビデオで実装予定）

![[Pasted image 20241020125614.png]]

![[Pasted image 20241020154714.png]]

![[Pasted image 20241020154414.png]]

![[Pasted image 20241020154817.png]]

1. ユーザーモデルに関連する関数を実装：
    - CheckAvailability: メールアドレスの重複チェック
    - Create: 新規ユーザー作成（パスワードをハッシュ化して保存）

![[Pasted image 20241020154842.png]]

1. HTMLテンプレートにアラート表示用の要素を追加します。

これらの手順により、基本的な認証システムの骨格が実装されました。次のビデオでは、ログインとログアウト機能を完成させる予定です。

# Login and logout

![[Pasted image 20241020161636.png]]

![[Pasted image 20241020161653.png]]

1. アプリケーションに認証を追加するため、全てのAPIコールでセッションの存在を確認する必要があります。
2. この機能をミドルウェアに移動させます。ミドルウェアはリクエストとコントローラーの間に位置します。
3. 設計するミドルウェアの機能：
    - APIからセッション情報を読み取る
    - ユーザー詳細を取得する
    - ユーザーIDとメールアドレスをGinのコンテキストにセットする
4. これにより、コントローラーはログインユーザーのIDにアクセスでき、ユーザーIDの有無に基づいてログイン状態を判断できます。

![[Pasted image 20241020162751.png]]

1. コードの実装：
    - 「middleware」フォルダを作成
    - 「auth.go」ファイルを作成
2. カスタムミドルウェアの実装：
    - 「AuthenticateUser」関数を作成（戻り値の型はgin.HandlerFunc）
    - この関数内で、コンテキストを受け取る別の関数を返す
3. セッション情報の取得：
    - コンテキストからデフォルトセッションを取得
    - セッションから「ID」キーの値を取得（ログインまたはサインアップ時にセットしたもの）
- ユーザーモデルのインスタンスを作成します。
- `userPresent`という変数を作成し、初期値をtrueに設定します。
- セッションIDが存在しない場合、セッションがないことを意味するので`userPresent`をfalseに設定します。
- セッションが実際の有効なユーザーに属しているかを確認します：
    - `models.UserFind(sessionID)`を呼び出してユーザーオブジェクトを取得します。

![[Pasted image 20241020163119.png]]

- UserFind関数をユーザーモデルに実装します：
    - パラメータとしてIDを受け取り、ユーザーへのポインタを返します。
    - ユーザーのインスタンスを作成し、IDで検索クエリを実行します。
    - 最初の行を取得し、ユーザー変数のアドレスを返します。

![[Pasted image 20241020163449.png]]

- ミドルウェアに戻り、ユーザーが存在する場合の処理を行います：
    - ユーザーIDが0より大きい場合、ユーザーが存在すると判断します。
    - ユーザーが存在する場合、GinのコンテキストにユーザーIDとメールアドレスをセットします：
        - `c.Set("userID", user.ID)`
        - `c.Set("email", user.Email)`
- 関数の最後で`c.Next()`を呼び出し、次のミドルウェアに制御を渡します。

1. ミドルウェアチェーンの最後の場合、制御はコントローラーに移ります。
2. カスタムミドルウェアの準備ができましたが、まだチェーンに追加していません。

![[Pasted image 20241020164002.png]]

1. main.goファイルに移動し、ミドルウェアを追加します：
    - `r.Use(middleware.AuthenticateUser())` を追加します。
    - これだけで、カスタムミドルウェアがチェーンに追加されます。
2. セッション管理のために作成したヘルパー関数を使用します。sessionsパッケージ自体もミドルウェアです。
3. カスタムミドルウェア（AuthenticateUser）の前にセッションミドルウェアを追加する必要があります：
    - `store := memstore.NewStore([]byte("secret"))`でセッションストアを作成します。
    - `r.Use(sessions.Sessions("mysession", store))`でセッションミドルウェアを追加します。
4. これにより、セッションミドルウェアがカスタムミドルウェアの前に追加されます。

![[Pasted image 20241020164243.png]]

1. ルートハンドラ（"/"）でHTMLをレンダリングする際、ユーザーがログインしているかどうかを示す追加のキー"loggedIn"を渡します：
    - `c.GetUint64("userID")`を使用してコンテキストから直接この情報を取得できます。
- ユーザーIDが0より大きい場合、ユーザーはログインしていると判断します。

![[Pasted image 20241020164525.png]]

- indexページのテンプレートに移動します。ここにログインとサインアップのボタングループを追加しました。
- ユーザーのログイン状態に基づいてボタンの表示を切り替えます：
    - ログイン中の場合：ログアウトボタンを表示
    - ログインしていない場合：ログインとサインアップボタンを表示
- ログアウト（/logout）はPOST APIなので、ログアウトボタンを実装するために空のフォームを作成します。
- main.goに移動し、まだ実装していない2つのPOST API（/loginと/logout）を確認します。

![[Pasted image 20241020165804.png]]

- SessionsControllerに移動し、これらのハンドラ関数を実装します。
- まずログイン機能を実装します：
    - このハンドラはログインフォームが送信されたときに呼び出されます。
    - フォームからメールアドレスとパスワードを読み取ります（サインアップハンドラからコードをコピーできます）。
- メールアドレスとパスワードが一致するかチェックする関数を呼び出します：
    - models.UserCheck(email, password)という関数を想定します（まだ実装されていない）。

![[Pasted image 20241020170253.png]]

1. ユーザーモデルに移動し、UserCheck関数を実装します：
    - 引数としてemailとpasswordを受け取り、userを返します。
    - まず、与えられたメールアドレスでユーザーを検索します。
    - ユーザーが存在しない場合はnilを返します。
    - パスワードチェックには先に実装したcheckPasswordHash関数を使用します。
    - パスワードが一致すればユーザーを、一致しなければnilを返します。

![[Pasted image 20241020171335.png]]

1. コントローラーに戻り、ログイン処理を完成させます：
    - ユーザーが存在する場合、セッションを設定し、インデックスページにリダイレクトします。
    - ユーザーが見つからない場合、ログインページにアラートメッセージと共にリダイレクトします。
2. ログアウト機能を実装します：
    - セッションをクリアし、ログインページを表示します。
    - アラートメッセージ「ログアウトしました」を表示します。

![[Pasted image 20241020171612.png]]

1. ユーザーモデルのマイグレーションを追加します：
    - models/setup.goのDbMigrate関数に、ユーザーモデルのマイグレーションを追加します。
2. アプリケーションを実行し、MySQLコンソールでテーブルを確認します：
    - 実行前は「notes」テーブルのみでしたが、実行後は「notes」と「users」の2つのテーブルが存在します。
    - usersテーブルの構造がモデルで定義したものと一致することを確認します。
3. サーバーを起動し、ログイン機能をテストします：
    - 正しいメールアドレスとパスワードでログインすると、ホームページにリダイレクトされ、ログアウトボタンが表示されます。
    - ログアウトをクリックすると、ログインページに戻り、「ログアウトしました」というアラートが表示されます。
    - 間違ったパスワードでログインを試みると、ログインページに戻り、「メールアドレスまたはパスワードが一致しません」というアラートが表示されます。

これらの実装により、基本的なユーザー認証システム（ログイン、ログアウト、パスワード検証）が完成しました。また、データベースにユーザー情報を保存するためのテーブルも正しく作成されています。

# add user id to the models

![[Pasted image 20241020172438.png]]

- アプリケーションにはすでにユーザーのサインアップとログイン機能がありますが、現在すべてのノートが全ユーザーにアクセス可能です。
- この動画では、ユーザーが自分のノートにのみアクセスできるように変更を加えます。

![[Pasted image 20241020173045.png]]

- notesモデルに変更を加えます：
    - ノート構造体に新しいフィールド「UserID」（uint64型）を追加し、インデックスを設定します。
    - このフィールドはノートの所有者のユーザーIDを保存します。
- モデルの全ての関数に変更を加えます：
    - NotesAll関数：ユーザーポインタを新しいパラメータとして追加し、DBクエリにユーザーIDの条件を追加します。
    - NoteCreate関数：ユーザーをパラメータとして追加し、ノートインスタンス作成時にUserIDフィールドを設定します。
    - 他の関数も同様に変更します。

![[Pasted image 20241020173210.png]]

- コントローラーにも同様の変更を加えます：
    - NotesIndex関数：現在サインインしているユーザーを取得し、そのユーザーに属するノートのみを取得します。



- コンテキストからユーザーIDを取得し、ユーザー情報を取得する処理を共通化します：
    - controllers/helpers ディレクトリを作成し、utils.goファイルを作成します。
    - GetUserFromRequest関数を実装し、gin.Contextを受け取り、現在のユーザーを返すようにします。

1. コントローラーのNotesIndex関数に戻り、GetUserFromRequest関数を呼び出して現在のユーザーを取得します。
2. ユーザーがサインインしていない場合、未認証アクセスとして処理します：
    - 現在のユーザーがnilか、IDが0の場合、ユーザーはサインインしていないと判断します。
    - この場合、ステータスコード「未認証」でHTMLをレンダリングし、「未認証アクセス」というアラートを表示します。
3. 他のハンドラー関数にも同様の変更を加えます。
4. MySQLコンソールでノーステーブルの構造を確認します：
    - サーバーを再起動してマイグレーションを実行し、user_idカラムが追加されたことを確認します。
5. ノーステーブルのuser_idの値を確認します：
    - 現時点では全てのuser_idがnullであることを確認します。
6. アプリケーションにサインインし、ノートが表示されないことを確認します（user_idがnullのため）。
7. MySQLで、いくつかのノートにuser_id = 1を、残りのノートにuser_id = 2を割り当てます。
8. ブラウザで2番目のユーザーでサインインし、/notesにアクセスします：
    - このユーザーに属するノートのみが表示されることを確認します。
9. 1番目のユーザーでサインインし、同様に確認します：
    - このユーザーに属するノートのみが表示されることを確認します。

