ReactとGoを使っての開発へようこそ。
このコースでは、Reactのフロントエンドを使用してシングルページアプリケーションを構築する方法を学びます。
Reactはバージョン18、React Routerはバージョン6を使用し、そのフロントエンドの全データはGoで構築されたREST APIおよびGraphQLから供給されます。
この詳細については後ほど説明します。

このコースで学ぶことは何か？
Reactを網羅し、シングルページアプリケーションを構築するために必要なコンポーネント、ステート、フック、refsといった重要な事項をカバーします。

コースの最初のセクションでは、従来のクラスを用いた方法と、最新の関数型コンポーネントとフックを用いた方法の両方を使ってReactアプリケーションを構築する方法を学びます。

次に、Go（一般的に「Golang」と呼ばれる）でREST APIのバックエンドを構築し、Postgresデータベースの上に構築します。また、GraphQLの導入についても取り上げ、PostgresをバックエンドとしたグラフデータベースからフロントエンドでGraphQLを使用してクエリを実行します。GraphQLは近年ますます人気を集めています。

このアプリケーションでは、JOTS、JWT、JSON Webトークンを使ってユーザー認証を行います。また、リフレッシュトークンを導入し、ユーザーが再度ユーザー名やパスワードを入力しなくても自動的に再認証されるようにします。

では、なぜReactを使うのでしょうか？

まず、Reactは比較的学びやすいです。複雑ではなく、現在では基本的なJavaScriptです。クラスを除いてしまえば、JavaScriptとフックのみです。
Reactアプリケーションを作成する上で最も重要なことは、コンポーネントの動作を理解することです。
なぜなら、Reactにおいてすべてはコンポーネント、つまり再利用可能なコンポーネントだからです。
例えば、このコースではいくつかのフォームを作成しますが、手作業でフォームを作るのではなく、テキスト入力用のコンポーネントや、チェックボックス用のコンポーネント、セレクト用のコンポーネントなどを作成し、それらを必要なだけ再利用してフォームを構築していきます。

つまり、賢いコンポーネントを構築することで、フォームがより便利になり、構築も容易になります。

Reactは非常に高速で、アプリケーションを構築する際には常に良い点です。
理解に少し時間がかかる概念として、**単方向データフロー**がありますが、これはほとんどのシングルページアプリケーションで一般的です。また、Reactには大規模なユーザーコミュニティがあるため、リソースやサポートを見つけるのが比較的簡単です。

次に、なぜGoを選ぶのかについて説明します。

Goは近年非常に人気が高まっており、バックエンドアプリケーションを構築するための非常に人気のある言語です。
このコースで行う内容そのものです。
Goは非常に学びやすく理解しやすい言語であり、特に並行処理のサポートが標準で組み込まれている点が、他のほとんどの言語より優れています。
唯一、Rustが同等またはそれに近いと言えるでしょう。

Goは型安全な言語であり、例えば整数型の変数を宣言すると、その変数には整数のみを格納できます。JavaScriptやPHPのような言語から移行してきた人にとっては新しいかもしれませんが、コードをバグが少なくなるようにします。

最後に、Goは単一のバイナリにコンパイルされます。
つまり、アプリケーションの構築が完了した後、バックエンドアプリケーションは1つのファイルをサーバーにコピーして起動するだけで動作します。
それが私たちのバックエンドAPIになります。

このコースでは何を構築するのでしょうか？
シングルページアプリケーションを構築し、ユーザー認証、レコードの追加、更新、削除といった標準的な機能を備えたものを作成します。
バックエンドはGoで書かれ、JSONとGraphQLの両方を扱い、フロントエンドはReactで構築されます。
最後に、JSON Webトークン（JOTS）を使ってサイトを保護します。

では、具体的にどんなアプリケーションを作るのか見ていきましょう。
このコースの第2セクションで構築するアプリケーションがこちらです。
最初のセクションはReactの基本的な練習です。

見た目の面ではあまり魅力的ではないかもしれませんが、このコースはグラフィックデザインのコースではなく、Reactでアプリケーションを構築し、Goでバックエンドを構築する方法を学ぶコースです。

アプリケーションでは映画をブラウズして、今夜見る映画を探せます。
映画のリストが表示され、少数しか選択肢はありませんが、コースの目的には十分です。
例えば、「ゴッドファーザー」をクリックすると、映画の写真、説明、関連情報が表示されます。
非常にシンプルです。

また、ジャンル別に映画をブラウズすることもできます。
例えば、冒険映画だけを見たいときには、恐らく1本しかありませんね。
「レイダース/失われたアーク《聖櫃》」です。

とてもシンプルですが、ログインもできます。

こちらで「 admin@example.com 」というユーザー名と適切なパスワードでログインしてみます。
現在、画面上部には「ログイン」と表示されており、メニュー項目は3つだけです。
ログインすると、バックエンドに接続し、JSON Webトークンとリフレッシュトークンが返されます。

ログイン後は、機能が増えます。
映画を閲覧するだけでなく、新しい映画を追加できるようになります。
ここで必要な情報をすべて入力し、追加する映画が該当するジャンルをチェックして保存します。
これにより、新しい映画がデータベースに登録されます。

カタログの管理もでき、個々の映画を見て自由に変更を加え、再度保存することも可能です。

最後に、同じデータベースを閲覧する方法として、今回はGraphQLを使用したグラフデータベースも扱います。
GraphQLはフロントエンドのデザイナーに非常に好まれており、必要な情報を得るためにバックエンドをプログラマーに変更してもらう必要がなくなります。

GraphQLの使い方の基本も学びます。
例えば、こちらの映画リストと先ほどのリストの違いは、名前でフィルターできる点です。
例えば、「the」と入力すると、タイトルに「the」を含む映画だけが表示されます。

とても楽しみですね。それでは始めましょう。
# Getting Started with React
## How React Works
では、初めてのReactアプリケーションを作成しましょう。

まず、お気に入りのターミナルを開きます。
ここでは、ターミナルを開いてデスクトップに移動します。
私はMacを使用しているので、デスクトップに移動しますが、作業場所は自由に選んでください。

デスクトップフォルダに移動し、新しいディレクトリを作成します。
ディレクトリ名は`React-apps`とします。
作成したディレクトリに移動し、その中が空であることを確認します。

Reactアプリケーションを作成するにはどうすればいいでしょうか？
幸いにも、Nodeがインストールされていれば非常に簡単です。
次のコマンドを入力します：

```bash
npx create-react-app my-app
```

ここで、`npx`は正しいコマンドです。
これはスペースを空けて入力し、その後に`create-react-app`と、最後にアプリケーションの名前を指定します。
今回は`my-app`とします。

リターンキーを押すと、過去に`create-react-app`のバージョンがインストールされている場合、メッセージが表示されることがあります。
React 18を使用しているため、古いバージョンでは使用できない旨の通知が来るかもしれません。
その際は、以下のコマンドでアンインストールしてください：

```bash
npm uninstall -g create-react-app
```

アンインストールが完了したら、再度以下のコマンドを入力します：

```bash
npx create-react-app my-app
```

この時、`create-react-app`のインストールを確認されることがありますが、Enterを押せばインストールが始まります。

初めてこのコマンドを実行する場合、インストールには数分かかることがありますが、次回以降はかなり速くなります。
インストールが完了するまで待つと、使い方の指示が表示されます。

インストールが完了すると、作成されたディレクトリ（今回は`my-app`という名前で指定したもの）の中で使用できるコマンドが表示されます。
たとえば、`npm start`を実行すると開発サーバーが起動します。
これをすぐに試してみましょう。
それ以外のコマンドについては後で説明します。

では、Visual Studio Codeを開きます。
VS Codeを起動し、新しいウィンドウを作成します。
ファイルブラウザをクリックし、「Open Folder」を選択してデスクトップ上のReactアプリケーションフォルダを見つけます。
先ほど作成した`my-app`フォルダをダブルクリックして開きます。

フォルダの中身を見ていきましょう。
`node_modules`フォルダがありますが、これは編集対象ではないためグレーアウトされています。
これはNodeによってインストールされたパッケージで、Reactが使用します。
中には多くのファイルが含まれていますが、今は無視して構いません。
Nodeがすべて処理してくれます。

次に`public`フォルダがあります。
これを開いてみましょう。
その中には`favicon`が含まれています。
WebアプリケーションやWebページを扱ったことがあるなら、このアイコンが何か知っているでしょう。

それは、Firefoxや他のウェブブラウザのタブに表示される小さなバッジです。
そして、`index.html`も含まれています。

その`index.html`を見てみましょう。
標準的なHTML5の形式で、言語タイプが宣言されています。
`head`セクションには標準的な要素が並んでおり、多くのコメントも含まれています。
その中には、通常のHTMLと異なる点に注目させるコメントもあります。

例えば、5行目の`favicon`へのリンクでは、`href`属性が`%PUBLIC_URL%`となっています。
下の`Apple Touch icon`や`manifest`でも同様の構造になっており、コメントでもそのことが説明されています。

コメントには、「`%`記号で囲まれた`PUBLIC_URL`は、ビルドフェーズ中に`public`フォルダのURLに置き換えられます」とあります。
これは開発フェーズではなく、アプリケーションが完成して本番環境に移す際のビルドフェーズで重要になります。

わかりやすくするために、これらのコメントを削除してHTML本体だけを見てみましょう。
コメントを削除すると、実際のHTMLはあまり多くはありません。
`head`タグの内容を除くと、`<noscript>`タグがあり、「このアプリケーションを使用するにはJavaScriptが必要です」と表示されています。

そして、空の`<div>`要素が1つあり、`id`は`root`です。
この`<div>`は何も含んでいません。

次に、統合ターミナルを開きましょう。

![[Pasted image 20241109223259.png]]

Visual Studio Codeの一部である統合ターミナルを開くと、現在のフォルダ（`my-app`）内のコマンドプロンプトが表示されます。
ここで、`npx create-react-app`によって指示された`npm start`コマンドを実行し、アプリケーションを起動します。
このコマンドにより、Webブラウザが開き、実行中のアプリケーションが表示されます。

表示されたページには、回転するロゴと、「やるべきこと」の簡単な説明、Reactを学ぶためのリンクが見えます。
次に、このページのソースコードを確認してみます。
標準的な「ソースの表示」コマンドを使用してソースを見ると、内容は非常にシンプルであることがわかります。
`<body>`タグには`<noscript>`タグと、空の`id="root"`を持つ`<div>`タグしかありません。
回転するロゴやテキストなどは存在していません。

この状態を閉じて、ソースの代わりにページを「検証」してみましょう。
ページ上で右クリックし、「検証」を選択します。
すると、画面上で実際に見えている内容が表示されます。
`<div id="root">`はもう空ではなく、内部に`class="App"`を持つ`<div>`と`<header>`が含まれています。
その中に画像、段落テキスト、リンクがあります。

これらの要素はどこから来ているのでしょうか？
IDEに戻り、Visual Studio Codeで確認してみましょう。
ターミナルは非表示にしますが、アプリケーションは引き続き実行しておきます。

次に重要なフォルダへ移動します。
`public`フォルダの残りの内容は今は無視しますが、大きな驚きはありません。

`public`フォルダ内には、いくつかの画像、`manifest`ファイル、`robots.txt`ファイルがあり、これらはWebアプリケーションやWebページでは一般的です。

次に`src`フォルダを見てみましょう。
まずは`index.js`ファイルを見てみます。
通常、`index`という名前が付いているファイルがスタートポイントですので、ここから始めましょう。

このファイルは標準的なJavaScriptコードで、JavaScriptアプリケーションを扱ったことがあれば驚くことはほとんどないでしょう。
1行目から始まる`import`文で、`react`を`React`としてインポートしています。
これはReactフレームワークを構成するJavaScriptパッケージの1つで、`node_modules`から取得しています。

次に、`react-dom/client`から`reactDom`をインポートしています。
これは、Reactプロジェクトを構築・保守しやすくするために、複数のパッケージに分割された一部です。

さらに、`./index.css`をインポートしています。
これにより、`index.css`というカスケーディングスタイルシート（CSS）がプロジェクトに取り込まれます。
このCSSは、`body`のフォントを変更し、コードタイプに特定のフォーマットを適用する役割を持っています。

もしこの`import`文をコメントアウトして削除したらどうなるでしょうか？
CSSのインポートを削除しても、アプリケーションは特に問題なく動作し続けます。

エラーメッセージは出ませんが、ターミナルを開いたままにしておけば、再コンパイルされたことがわかります。
ここにそのメッセージがあります。

Webブラウザに戻ってみると、開発ツールを閉じた状態で、フォントが変わっていることがわかります。
ブラウザのデフォルトフォントに戻り、`body`の見た目も少し変わっています。

では、IDEに戻り、コメントアウトした`import`文を元に戻して保存します。
すると、再コンパイルが非常に迅速に行われます。
ブラウザに戻ると、すべてが元通りになり、見た目も良くなります。
`body`全体の境界線がなくなり、フォントも再び適用されました。
開発中、このCSSは非常に役に立つでしょう。

`index.js`ファイルに戻ると、`import`文には特に驚く点はありません。
7行目には`root`という定数があり、`ReactDOM`（2行目でインポートしたもの）から`createRoot`を使ってアプリケーションのルートを作成しています。
特定の場所、つまり`document.getElementById("root")`に基づいて作成されます。
この`root`が何かはすでにわかっているでしょう。
それは`index.html`内の`id="root"`を持つ`<div>`を指しています。
この`<div>`内にWebアプリケーション全体が存在します。

次に、`root.render`がこのファイルで重要な最後の部分です。
`reportWebVitals`については気にしなくても構いません。

実際、この`reportWebVitals`はそのうち削除する予定ですが、今はそのままにしておきます。

`root.render`の中には、開きと閉じの括弧があり、その中に`<React.StrictMode>`タグが開閉し、その間に`<App />`タグがあります。

この`App`とは何でしょうか？
インポートの行を見上げると、`import App from './App';`と記述されています。
そこで`./App`を探すと、`App.js`が見つかります。
これを開くと、Reactの最初のコンポーネントを目にすることになります。
以前の講義で述べたように、Reactではすべてがコンポーネントとして構成されています。
この`App`はその一例です。

`App.js`には2つのインポートがあります。
最初のものはSVG（スケーラブル・ベクター・グラフィック）ファイルをインポートしており、Reactアプリケーションに画像を組み込んでいます。
これは少し奇妙に思えるかもしれませんが、Reactではこのように動作します。
もう1つはCSSファイルをインポートしており、これは標準的なスタイルシートです。

注目すべきは、この関数型コンポーネントです。
React 16以前は、コンポーネントはクラスを使用して作成するのが一般的でしたが、React 16以降、関数型コンポーネントとフックを使う方法が主流になっています。
現在でもクラスを使ったコンポーネントは多くのコードで見られるため、その方法を知っておくことも重要です。

この`App`コンポーネントはフックを含んでいませんが、関数型コンポーネントです。
`App`という名前のシンプルなJavaScript関数があり、25行目で`export default App;`とエクスポートされています。
このエクスポート文によって、`index.js`で`App`としてインポートできるようになります。

`App`関数はHTMLに似たものを返しますが、厳密にはHTMLではなく、JSX（JavaScript XML）と呼ばれるものです。
HTMLに非常に似ていますが、いくつかの違いがあります。

その違いの一つは、6行目の`<div>`タグです。
`class="app"`ではなく、`className="app"`と記述されています。
これは、`class`がJavaScriptでは予約語であり、オブジェクト指向プログラミングの一部だからです。
Reactでは代わりに`className`を使用します。

もう一つの違いは、8行目の`<img>`タグです。
`src`属性には画像のフルパスを記述する代わりに、`{logo}`という単一の中括弧で囲んだ変数が使われています。

この`logo`はJavaScriptの式で、1行目の`import logo`から参照されています。
このインポートによって画像ファイルの適切なパスが取得され、アプリケーションがビルドされてレンダリングされる際に、そのパスがHTML（正確にはJSX）としてブラウザに送信されます。

ブラウザに戻ると、「Edit `src/App.js` and save to reload.」という行があります。
これを変更してみましょう。
「Edit」を「You can edit」に変更し、保存します。
なお、私はVisual Studio Codeの「AutoSave」オプションを有効にしているので、毎回保存する手間が省けます。
これを設定しておくと便利です。

ブラウザに戻ると、すぐに「You can edit `src/App.js` and save to reload.」に変更されていることが確認できます。

他にも多くのファイルがありますが、それぞれを個別に説明するのは避け、もう少し難しいが有用なアプローチを取ります。
次の講義では、これらのファイルのほとんどを削除し、`index.js`の内容をすべて消して、シンプルな「Hello, World」アプリケーションをゼロから構築します。

では、次に進みましょう。

## Hello world with React using Classes
現在、私たちのReactアプリケーションは機能していますが、`npx create-react-app`コマンドで作成したデフォルトアプリケーションとほぼ同じです。
ここまでの作業で、少しコードを変更しただけです。
では、このアプリケーションを少し変えてみましょう。

まず、IDEに戻り、開いているファイルをすべて閉じます。
アプリケーションを実行したままにしておきますが、これからいくつかエラーが発生するのをターミナルで確認できます。
ここから少し複雑にしていきます。

まず、`src`フォルダ内のいくつかのファイルを削除します。
`App.js`、`App.css`、`App.test.js`、`index.css`を削除し、`index.js`だけは残しておきます。
これらをゴミ箱に移動し、削除します。すると、コンパイルエラーが発生しますが、エラーメッセージは「モジュールが見つからない、`App.js`を解決できない」というものです。
これは、`index.js`で存在しないファイルをインポートしているからです。

そのため、インポート文のうち、`react`と`react-dom`以外の不要なインポートを削除します。さらに、コメント行や`reportWebVitals`の行も削除します。まだエラーは残りますが、それは`App`というものを参照しているためです。`App`は存在せず、インポートもしていないためです。

そこで、新しいファイルを`src`フォルダに作成し、`AppClass.js`という名前を付けます。このファイルで新しいコンポーネントを作成しますが、今回は関数型コンポーネントではなく、クラスコンポーネントを使用します。これはReact 16以前の方法です。

コンポーネントを作成するため、次のように入力します：

```javascript
import React, { Component } from 'react';
```

このインポート文は、`React`と`Component`を`react`から取り込むことを示しています。

インポートは完了しましたが、エラーが残っています。
`App`ファイルがまだないため、エラーが続いています。
これについては一旦閉じて、クラスコンポーネントの作成に集中しましょう。

初めてのReactクラスコンポーネントを作成します。
次のコードを入力します：

```javascript
export default class AppClass extends Component {
    render() {
        return (
            <div>
                Hello, World!
            </div>
        );
    }
}
```

ここで`export default`を使用し、`class`というキーワードでクラスを定義しています。
このクラスの名前は`AppClass`で、`Component`を拡張（`extends`）しています。
`Component`はReactに組み込まれているクラスです。

クラスコンポーネントでは必ず`render`関数が必要です。
この関数はJSXを返すもので、今回は単純に「Hello, World!」を返す構造にしています。
`render`関数内のJSXは`<div>`にラップして返されています。

これで基本的なクラスコンポーネントが完成です。

新しいプログラミング言語やプラットフォームを紹介する際に「Hello, World」アプリケーションを作らなかったら、何か悪いことが起こるような気がします。
おそらく教える資格が取り消されるかもしれませんね。
でも、ここではしっかり「Hello, World」アプリケーションを作成しました。

`render`メソッドの後には、必要はないかもしれませんが、私は通常セミコロンを付けるようにしています。
これで`AppClass.js`は完成しました。

ターミナルを開くと、まだエラーが発生しているかもしれません。それは、`App`が定義されていないからです。`index.js`に戻って、次のようにインポート文を追加します：

```javascript
import AppClass from './AppClass';
```

これで、`AppClass`がインポートされました。次に、`index.js`内の`<App />`を`<AppClass />`に変更します。

```javascript
root.render(
    <React.StrictMode>
        <AppClass />
    </React.StrictMode>
);
```

これを保存すると、ターミナルでコンパイルが成功したメッセージが表示されるはずです。
Webブラウザに戻ると、画面には「Hello, World」と表示されています。

特に目新しさはないかもしれませんが、ご覧のとおり、使わないコードを削除してコードを整理しました。
`index.js`を修正して、唯一のコンポーネントである`AppClass`をインポートし、`root.render`内の名前を`<AppClass />`に変更しました。

`AppClass`の定義は`./AppClass`にあり、これは`src`フォルダ内のこのファイルです。
このクラスコンポーネントは非常にシンプルで、`<h1>`タグに囲まれた「Hello, World」を返します。
これがクラスコンポーネントを作成する方法です。

次の講義では、同じことを関数型コンポーネントを使って実現します。それでは、次に進みましょう。

## Hello woeld with React using functional components
現在、単一のクラスコンポーネントがあり、「Hello, World」というテキストをウェブページのタイトルとしてレンダリングするだけのものです。
今回は同じことを行いますが、クラスコンポーネントではなく、関数型コンポーネントを使用します。

ちなみに、ブラウザで [reactjs.org](https://reactjs.org) にアクセスし、今私がクリックしているようにドキュメントリンクを開くと、この公式サイトには多数のクラスコンポーネントの例とリファレンスが載っています。
しかし、beta.reactjs.org という新しいリンク先を訪れると、これがReactの新しい姿であることがわかります。

今後、Reactの公式ドキュメントはクラスコンポーネントではなく、関数型コンポーネントとフック（hooks）を使ったものに移行していく予定です。
これは、Reactの将来が関数型コンポーネントとフックにあることを示しています。

以前のバージョンのこのコースでは、最初はほぼクラスコンポーネントに専念していました。
そして、コースの最後で全てを関数型コンポーネントに変換していました。
しかし、今録画している新しいバージョンでは、Reactの方向性に従って、関数型コンポーネントとフック（hooks）の使用に重点を置きます。

では、IDEに戻りましょう。
このファイルは開いたままにしておいて、`src`フォルダに新しいファイルを作成します。
このファイルは`Hello.js`とします。
これは関数型コンポーネントで書かれた「Hello, World」アプリケーションになります。

どうやって作るのでしょうか？
`AppClass.js`では`React`と`Component`をインポートしましたが、今回は次のようにします：

```javascript
import React, { Fragment } from 'react';
```

`Fragment`はReactで使用されるもので、知っておくべき要素です。
これらはすべて`react`からインポートされる必要があります。

では、関数型コンポーネントを定義するにはどうすれば良いでしょうか？
単にJavaScriptの関数を作成するだけです：

```javascript
function HelloWorld() {
	return (
		<hr />
		<h1>Hello, World</h1>
	);
}
```

この関数は標準的なJavaScript関数で、JSXを返すだけです。
`<h1>`タグで「Hello, World」を表示し、`<hr />`タグで水平線を表示します。

JSXと純粋なJavaScriptの違いとして、JSXではセルフクロージングタグ（`<hr />`など）を正しく閉じる必要があります。
Webページでよく使われる形式では、単に`<hr>`と書くことがあると思いますが、JSXではセルフクロージング形式でなければなりません。

これが関数型コンポーネントの基本的な作り方です。

最初の部分では単に`<hr>`と書いていたかもしれませんが、JSXではすべての開くタグに閉じるタグが必要です。
ですので、`<hr></hr>`と書くこともできますが、多くの場合、セルフクローズタグとして`<hr />`と書くのが一般的です。これも問題なく動作します。

これで水平線が返されますが、さらに`<h1>`タグで「Hello, World」を返したいと思います。
そこで`<h1>Hello, World</h1>`と書くと、エラーが表示されます。
エラーの内容は、「JSX式は1つの親要素を持たなければならない」というものです。

では、これらを1つのタグで囲むにはどうすればいいでしょうか？
先ほどインポートした`Fragment`を使用します。
`Fragment`を開くタグとして使い、その閉じるタグを最後に配置します。
これにより、複数の要素を1つの親要素でラップすることができます。

```javascript
function HelloWorld() {
	return (
		<Fragment>
			<hr />
			<h1>Hello, World</h1>
		</Fragment>
	)
}
```

これで有効なJSXになりました。
見た目を良くするためにインデントを調整します。

React 18では`Fragment`を省略するショートハンドも使用できます。
`<Fragment>`タグを削除し、代わりに空のタグ`<>`と`</>`で囲むことができます：

```javascript
function HelloWorld() {
	return (
		<>
			<hr />
			<h1>Hello, World</h1>
		</>
	)
}
```

これで、複数の要素を1つの親要素でラップするJSXが完成しました。

もちろん、未使用の`Fragment`をインポートしているので、それを元に戻しますが、これまでに紹介した2つの方法に注意を向けたかったのです。

さて、次に必要なことは何でしょうか？
`React`と`Fragment`をインポートし、関数を作成し、必要なJSXを返しています。
しかし、最後に次のような行を追加する必要があります：

```javascript
export default HelloWorld;
```

これで、このコンポーネントを他のファイルからインポートして使用することができます。
これは、関数型コンポーネントで、意図した通りに動作します。

この関数型コンポーネントは、クラスコンポーネントとは少し異なります。
`<hr />`タグを使い、全体を`Fragment`で囲んでいるのはそのためです。
次に`index.js`に戻り、次のようにインポート文を追加します：

```javascript
import HelloWorld from './HelloWorld';
```

そして、`<React.StrictMode>`の中に`<HelloWorld />`を自己閉じタグとして追加します：

```javascript
root.render(
	<React.StrictMode>
		<AppClass />
		<HelloWorld />
	</React.StrictMode>
);
```

この変更を保存したら、ターミナルを開いてコンパイルが成功するか確認します。
問題なくコンパイルされたら、ブラウザでアプリケーションを見てみましょう。
画面には「Hello, World」と2回表示されます。
1つはクラスコンポーネントによるもの、もう1つは関数型コンポーネントによるものです。

ここで「クラスコンポーネントと関数型コンポーネントを同じアプリケーションで使ってもいいのか？」という疑問が浮かぶかもしれません。答えは「全く問題ありません」。
実際、私が現在担当しているクライアントのプロジェクトでは、React 16でクラスコンポーネントを使用して書かれたアプリケーションに、新しい機能を追加する際は関数型コンポーネントとフックを使っています。
これらは問題なく共存し、アプリケーションは正常に動作しています。
最終的にはすべてのコンポーネントを関数型コンポーネントとフックに移行することが目標ですが、急ぐ必要はなく、すべて順調に進んでいます。

このようにして、`AppClass`と`HelloWorld`の2つのコンポーネントが完成しました。
次は、さらに複雑な内容に進んでいきましょう。

## Styling Components
現在、Reactアプリケーションには2つのコンポーネントがあります。
1つはクラスベースのコンポーネントで、「Hello, World」をブラウザに表示します。
もう1つは関数型コンポーネントで、同じく「Hello, World」を表示しますが、その上に水平線を追加しています。
今回は、これらのコンポーネントにスタイリングを追加する方法について説明します。

まず、IDEに戻り、`AppClass.js`を確認します。
このコンポーネントのすべての`<h1>`タグの色を赤に変更したいとします。

新しいCSSファイルを`src`フォルダ内に作成します。
慣例として、このCSSファイルの名前は適用するファイルと同じ名前にします。
したがって、`AppClass.css`という名前にします。
このファイルに次のようなCSSを記述します：

```css
h1 {
	color: red;
}
```

これで`AppClass.js`に対応するCSSファイルを作成しましたが、まだ使用していません。
`AppClass.js`に戻り、次のようにインポート文を追加します：

```javascript
import './AppClass.css';
```

これで`AppClass.js`内にCSSをインポートでき、スタイルが適用されるようになります。
これを保存すると、ブラウザに戻ったときに`AppClass`コンポーネント内の`<h1>`要素が赤色で表示されるようになります。

ブラウザを見てみると、スタイルを1つのコンポーネントに適用したつもりでも、両方のコンポーネントに影響を与えていることがわかります。
これは直感に反するようですが、ReactはCSSやJavaScriptをバンドルして1つのファイルにまとめるため、このようなことが起こります。
この場合、特定のコンポーネントにのみ影響を与えたいのであれば、`h1`タグ全体を再定義するのは避けるべきです。

では、これを修正しましょう。
`AppClass.css`に戻り、`h1`タグの代わりに次のようなクラスを作成します：

```css
.h1-red {
	color: red;
}
```

次に、`AppClass.js`に戻り、この`<h1>`タグにクラスを追加します。
ただし、`class`属性は使わず、`className`属性を使います：

```javascript
<h1 className="h1-red">Hello, World</h1>
```

これで、ブラウザに戻ったときに、スタイルが指定したコンポーネントだけに適用されるようになります。

さらに、このコンポーネントの`<h1>`タグを緑色に変更したい場合は、CSSファイルに新しいクラスを追加します：

```css
.h1-green {
	color: green;
}
```

そして、`AppClass.js`でクラスを更新します：

```javascript
<h1 className="h1-green">Hello, World</h1>
```

これで、この変更が保存され、ブラウザに表示された際に、指定されたコンポーネント内の`<h1>`タグが緑色になります。

それは難しくありません。
IDEに戻り、`src`フォルダ内に新しいCSSファイルを作成し、`HelloWorld.css`と名付けます。このファイルに次のように`h1`タグ用のクラスを宣言します：

```css
.h1-green {
    color: green;
}
```

次に、`HelloWorld.js`に移動し、このCSSファイルをインポートし、`<h1>`タグに適切なクラス名を適用します：

```javascript
import './HelloWorld.css';

function HelloWorld() {
	return (
		<>
			<h1 className="h1-green">Hello, World</h1>
			<hr />
		</>
	);
}
```

これで変更が保存され、ブラウザに戻ると、1つのコンポーネントは赤色、もう1つは緑色の`<h1>`タグが表示されていることを確認できます。

CSSの変更時には、実際のHTMLタグそのものを再定義することが必ずしも良いとは限らないことを覚えておくことが重要です。コンポーネントごとに異なるスタイルを適用したい場合は、そのコンポーネント専用のクラスを作成し、明確な命名規則を使用してどのコンポーネントにどのスタイルが関連しているかを理解しやすくしましょう。

次の講義では、プロジェクトをBootstrap（5.2や5.3などの最新バージョン）を使用するように修正します。それでは、次に進みましょう。

# Using Bootstrap CSS

# Using props:passing data to components 
今回取り組むのは、`props`（プロパティ）の使用についてです。HTMLを書いたことがあれば、実は常に`props`を使用しています。例えば、`<img src="example.jpg" alt="description" />`では、`src`や`alt`はプロパティです。同じ構文をReactアプリケーションで使用します。

現在、`index.js`には`AppClass`と`HelloWorld`の2つのコンポーネントがあります。`AppClass.js`を見てみると、このコンポーネントは単にメッセージを表示するクラスコンポーネントです。ここで、このメッセージをコンポーネント内で直接定義するのではなく、プロパティとして受け取るようにします。

次に、`AppClass.js`内の`<h1>`タグの中身を削除し、その部分をプロパティの参照に置き換えます。次のようにコードを変更します：

```javascript
import React, { Component } from 'react';
import './AppClass.css';

export default class AppClass extends Component {
	render() {
		return (
			<h1 className="h1-red">
				{this.props.message}
			</h1>
		);
	}
}
```

これで、`props`を通じて`message`というプロパティを取得し、その内容を`<h1>`タグ内に表示します。

次に、`index.js`でこの`AppClass`コンポーネントに`props`を渡します：

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppClass from './AppClass';
import HelloWorld from './HelloWorld';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
	<React.StrictMode>
		<AppClass message="Hello, from props!" />
		<HelloWorld />
	</React.StrictMode>
);
```

これにより、`AppClass`コンポーネントは`props`として渡されたメッセージを受け取り、`<h1>`タグ内に表示します。
ブラウザで確認すると、`AppClass`の表示が「Hello, from props!」に変更されているはずです。

まず、`AppClass.js`の中で`<h1>`タグ内に次のようにプロパティを参照するコードを書きます：

```javascript
<h1 className="h1-red">
	{this.props.msg}
</h1>
```

これで、`this.props`オブジェクトを通じて、`msg`というプロパティを参照します。
しかし、このプロパティはまだ設定していません。
アプリケーションを再起動して（`npm start`を実行し）、ブラウザに切り替えると、何も表示されていないことが確認できます。
これは、プロパティが設定されていないためです。

次に、`index.js`に戻り、`AppClass`コンポーネントに`msg`プロパティを指定します：

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppClass from './AppClass';
import HelloWorld from './HelloWorld';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
	<React.StrictMode>
		<AppClass msg="hello world" />
		<HelloWorld />
	</React.StrictMode>
);
```

これで、`msg`プロパティに「hello world」（小文字の`w`）が設定されました。
`AppClass.js`では、このプロパティを`this.props.msg`として読み込んでいます。

ブラウザに戻ると、「hello world」が小文字の`w`で表示されるはずです。
これで、プロパティを使用してコンポーネントにデータを渡す方法が理解できました。

クラスベースのコンポーネントでの`props`の使用方法を理解したところで、次に関数型コンポーネントでの使用方法を見ていきましょう。
`HelloWorld.js`ファイルでは、`props`を関数のパラメータとして渡すだけです。
これにより、非常に簡単に実装できます。

次のように関数を修正します：

```javascript
function HelloWorld(props) {
	return (
		<>
			<hr />
			<h1 className="h1-green">{props.msg}</h1>
		</>
	);
}
```

`props`を関数の引数として受け取り、その中の`msg`プロパティを`<h1>`タグ内でJavaScript式として使用しています。

次に、`index.js`に移動して、この`HelloWorld`コンポーネントに`msg`プロパティを渡します：

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppClass from './AppClass';
import HelloWorld from './HelloWorld';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
	<React.StrictMode>
		<AppClass msg="hello world" />
		<HelloWorld msg="hello again" />
	</React.StrictMode>
);
```

これで、`HelloWorld`コンポーネントは`props`として`msg`を受け取り、画面に「hello again」と表示されるようになります。

ブラウザで確認すると、関数型コンポーネントの表示が期待通りに「hello again」となっていることがわかるはずです。

一つ覚えておくべき点として、クラスベースの`AppClass`コンポーネントでは`this.props.msg`を使用していますが、関数型コンポーネントでは`props.msg`というシンプルな記法でプロパティを参照できます。
これにより、関数型コンポーネントはより直感的で簡潔に書けることがわかります。

クラスベースのコンポーネントであろうと関数型コンポーネントであろうと、`props`は読み取り専用です。
つまり、このコンポーネントは`msg`プロパティの値を変更することはできません。
`AppClass`や`HelloWorld`の中では、`props.msg`は読み取り専用であり、この関数の中ではその値を変更することはできません。

これが`props`を渡す基本的な原則です。
非常にシンプルで、Reactアプリケーションを構築する際、データを下流に押し込むという考え方が重要です。
つまり、親コンポーネントから子コンポーネント、さらにその子コンポーネントへとデータを流します。

今回の例では、`msg`プロパティの値は`index.js`内で設定されています。
この値を`HelloWorld`コンポーネントが認識していますが、他のコンポーネントの`msg`には影響を与えません。
`AppClass`の`msg`と`HelloWorld`の`msg`は互いに関連性がありません。

このように、親コンポーネントから子コンポーネント、さらにはその子コンポーネントへとデータを渡すことで、データの流れが一方向に保たれます。
Reactアプリケーションでは、`props`を使って情報を渡すことが一般的であり、これがデータを安全に管理し、アプリケーション全体を理解しやすくする方法です。

`props`は、それを受け取るコンポーネントにとって読み取り専用です。
ただし、この制限を回避する方法もありますが、それについては後ほど取り上げます。
通常、コンポーネント間で変化する情報に`props`を使用することはあまりありません。

その代わりに使用されるのが`state`です。
`state`は、クラスコンポーネントと関数型コンポーネントでの扱いが異なります。
次の講義では、`state`について詳しく見ていきましょう。

## React and State 1
`state`を試してみましょう。
`state`を使用するためには、イベントや条件付きレンダリングといった他の概念も紹介します。
まず、アプリケーションを少し簡素化してみましょう。

現在、ブラウザでは2つのコンポーネントが表示されていますが、それを簡素化します。
まず、`index.js`から`AppClass`コンポーネントを削除し、実際の`render`関数からも削除します。
これにより、関連する`import`文も削除できます。

これでブラウザに戻ると、アプリケーションがシンプルになり、「hello again」と水平線だけが表示されていることがわかります。
この状態を基に、さらに追加していきます。

次に、`HelloWorld.js`に移動し、`AppClass`を使用していないので、それを閉じて、不要なファイルも閉じておきます。
これで、作業に集中できる状態になります。

`HelloWorld`関数内で`state`を設定するために、`return`を呼び出す前に次のように記述します：

```javascript
import React, { useState } from 'react';

function HelloWorld() {
	// useStateフックを使ってstateを宣言
	const [isTrue, setIsTrue] = useState(false);
	
	return (
		<>
			<h1 className="h1-green">{props.msg}</h1>
			<hr />
		</>
	);
}
```

このコードでは、`useState`フックを使って`isTrue`という`state`変数を宣言しています。
この変数の初期値は`false`です。
`useState`は、関数型コンポーネントで`state`を使用するためのフックであり、2つの要素（`state`変数とその値を更新するための関数）を返します。
このため、分割代入の構文を使用して`isTrue`と`setIsTrue`を取得しています。

この`state`は初期値として`false`を持ち、`setIsTrue`関数を使って`isTrue`の値を更新できます。
変数名に「`set`」を付けることで、`state`を更新する関数であることが直感的にわかります。

`isTrue`を使って、条件付きで表示を変更することもできます。
この例では、`isTrue`が`true`の場合は「State is True!」と表示し、`false`の場合は「Hello, World」と表示されます。

これまでのところ、`useState`を使用して`isTrue`という状態を設定しました。
次に、この`isTrue`を利用して条件付きレンダリングを行います。

`<Fragment>`の中に追加するコードは以下のようになります：

```javascript
function HelloWorld() {
	const [isTrue, setIsTrue] = useState(false);
	
	return (
		<>
			<h1 className="h1-green">{props.msg}</h1>
			<hr />
			{isTrue &&
				<>
					<p>The current value of isTrue is true</p>
				</>
			}
		</>
	);
}
```

ここでは、`{isTrue && (...)}`という構文を使用しています。
この構文はJavaScriptの論理AND演算子を使用しており、`isTrue`が`true`の場合にのみ次の要素をレンダリングします。
`isTrue`が`false`の場合、何も表示されません。

`<p>`タグ内に「The current value of isTrue is true」というメッセージを表示し、`<Fragment>`を使用して要素をラップすることで、複数の要素が1つの親要素内に存在しているようにしています。
これはJSXの要件です。

これで、`isTrue`が`true`であれば「The current value of isTrue is true」と表示され、`false`であれば何も表示されません。

`isTrue`が`false`に設定されている状態で、条件付きレンダリングが動作していることを確認しました。
もし、`isTrue`を`true`に変更すると、条件付きで表示されるメッセージがブラウザに表示されます。
これは、条件付きレンダリングの一例です。
他の方法もありますが、後ほど紹介します。

次に、条件付きレンダリングの下にさらに要素を追加し、ボタンを表示します。
`<a>`タグをボタンのようにスタイリングするために、Bootstrapのクラスを使用します。

以下のコードを`HelloWorld.js`に追加します：

```javascript
function HelloWorld() {
	const [isTrue, setIsTrue] = useState(false);
	
	return (
		<>
			<h1 className="h1-green">{props.msg}</h1>
			<hr />
			{isTrue &&
				<>
					<p>The current value of isTrue is true</p>
				</>
			}
			<a href="#!" className="btn btn-outline-secondary" onclick={toggleTrue}>
				Toggle isTrue
			</a>
		</>
	)
}
```

このコードでは、`<a>`タグに`href="#!"`を設定し、`btn`と`btn-outline-secondary`というBootstrapのクラスを使用して、リンクをボタンのように見せています。
`href`に`#!`を設定することで、リンクをクリックしてもページの移動が発生しません。

これを保存してブラウザで確認すると、スタイリングされたボタンが表示され、条件付きレンダリングの要素が表示されるかどうかは`isTrue`の値に依存します。

このコードの意図を踏まえて、もう少し詳しく説明し、`toggleTrue`関数を見直します。
意図的に詳細に書かれたこのコードは、`isTrue`の状態を反転する方法を説明しています。

以下が、修正したコードです：

```javascript
import React, { useState } from 'react';

function HelloWorld(props) {
	const [isTrue, setIsTrue] = useState(false);

	const toggleTrue = () => {
		if (isTrue) {
			setIsTrue(false);
			return
		}
		setIsTrue(true)
	}
	
	return (
		<>
			<h1 className="h1-green">{props.msg}</h1>
			<hr />
			{isTrue &&
				<>
					<p>The current value of isTrue is true</p>
				</>
			}
			<a href="#!" className="btn btn-outline-secondary" onclick={toggleTrue}>
				Toggle isTrue
			</a>
		</>
	)
}

export default HelloWorld;

```

この`toggleTrue`関数は、`isTrue`が`true`の場合に`setIsTrue(false)`を呼び出して状態を`false`にし、処理を終了します。
`isTrue`が`false`の場合は、`setIsTrue(true)`を呼び出して状態を`true`に変更します。

このコードをブラウザで確認すると、ボタンをクリックするたびに`isTrue`の状態が反転し、条件付きレンダリングによって`<p>`タグが表示されたり消えたりします。

開発者ツールで確認すると、`<p>`タグがDOMから削除されたり追加されたりすることがわかります。
これが、Reactが状態を反映してDOMを更新する仕組みです。

この説明は`state`を使った状態管理の良い例です。
Reactでは、`state`の値が変更されると、その`state`に依存しているコンポーネントや要素が即座に再レンダリングされ、DOMが更新されます。
`state`を利用してDOM要素を条件付きでレンダリングすることにより、表示を完全に削除したり追加したりできます。

コードの詳細を以下に示します：

```javascript

{isTrue &&
<>
                    <p>The current value of isTrue is true</p>
                </>
            )}
            {/* 短絡評価演算子を使った条件付き表示 */}
            {isTrue ? <p>isTrue is true</p> : <p>isTrue is false</p>}
            <hr />
            {/* ボタン */}
            <a href="#!" className="btn btn-outline-secondary" onClick={toggleTrue}>
                Toggle isTrue
            </a>
        </>
    );
}

export default HelloWorld;
```

このコードには2つの条件付きレンダリング方法が含まれています：

1. `isTrue && <p>...<p>` のような短絡評価演算子を使用して、`isTrue`が`true`の場合のみ要素を表示する。
2. `isTrue ? <p>isTrue is true</p> : <p>isTrue is false</p>` という三項演算子を使って、`isTrue`が`true`なら「isTrue is true」、`false`なら「isTrue is false」を表示します。

ブラウザで確認すると、ボタンをクリックするたびに`isTrue`の状態が反転し、ページ上の表示が2つの場所で同時に変わることがわかります。これは、`state`がアプリケーション内で一貫して管理され、すべての関連要素が同期されるためです。

この基本的な例を使って、`state`を用いたリアクティブな表示の管理やイベントハンドリングを学ぶことができました。次は、より高度な`state`の操作や他のReactフックを組み合わせた実装を見ていきましょう。