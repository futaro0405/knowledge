# Goで並行処理(基本編)
## チャネルの性質と状態
チャネルは、その状態によって異なる挙動を示します。主な状態と挙動を以下にまとめます。

### チャネルの主な状態
チャネルと一言でいっても、その種類・状態には様々なものがあります。
1. nil チャネル
	- 宣言されただけで初期化されていないチャネル
	- 例：`var c chan int`
2. closed（閉じられた）チャネル
	- `close()`関数で閉じられたチャネル
3. バッファの状態
	- 空のバッファ
	- 値が入ったバッファ
	- 満杯のバッファ
4. 方向性
	- 送信専用チャネル
	- 受信専用チャネル
	- 双方向チャネル
### 状態に応じた挙動
#### a. nil チャネル
- 送信：ブロック（永遠に待機）
- 受信：ブロック（永遠に待機）
- close：パニック
#### b. open（開いている）チャネル
- 送信：バッファに空きがあれば成功、なければブロック
- 受信：値があれば成功、なければブロック
- close：成功（チャネルが閉じられる）
#### c. closed（閉じられた）チャネル
- 送信：パニック
- 受信：バッファに残っている値がある場合はそれを返す、ない場合はゼロ値を返す（ブロックしない）
- close：パニック

### 重要なポイント
- **nil チャネルは常にブロックされる**
	- nilチャネルに対する操作は永遠に待機状態になります。
	- これを利用して特定の操作を無効化することができます。
- **閉じられたチャネルは決してブロックされない**
	- 閉じられたチャネルからの受信は即座に完了します。
	- バッファに値が残っている場合はその値を、なければゼロ値を返します。
- **閉じられたチャネルへの送信はパニックを引き起こす**：
	- 閉じられたチャネルに値を送信しようとするとプログラムがクラッシュします。

これらの性質を理解することで、チャネルを使った並行プログラミングをより効果的に、そして安全に行うことができます。
特に、nilチャネルと閉じられたチャネルの挙動の違いは、プログラムの制御フローを設計する上で重要な要素となります。
## チャネルは同期の手段
チャネル、特にバッファなしチャネルは、データの送受信だけでなく、ゴールーチン間の同期にも使用されます。
これは非常に重要な概念です。

### バッファなしチャネルの同期機能
#### 送信側の挙動
- 受信側が準備できるまで、送信処理がブロックされます。
#### 受信側の挙動
- 送信側が値を送るまで、受信処理がブロックされます。
#### 同期のポイント
- 送信と受信が行われる瞬間が、ゴールーチン間の「待ち合わせ点」となります。

## 実際の例：ソート処理の完了を待つ
これを実感するためのいい例が[Effective Go](https://golang.org/doc/effective_go#channels)の中に存在します。
Effective Goからの例を簡単に説明すると

1. メインゴールーチン：
    - チャネルを作成します。
    - 別のゴールーチンでソート処理を開始します。
    - 他の作業（`doSomethingForAWhile()`）を行います。
    - チャネルからの受信を待ちます（`<-c`）。
2. ソート用ゴールーチン：
    - ソートを実行します。
    - 完了後、チャネルに値を送信します（`c <- 1`）。
3. 同期のポイント：
    - ソートゴールーチンが値を送信し、メインゴールーチンがその値を受信する瞬間。
    - この時点で、ソートの完了がメインゴールーチンに伝わります。

```go
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
	list.Sort()
	c <- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
<-c   // Wait for sort to finish; discard sent value.
```

### 重要なポイント

- チャネルを使うことで、複雑な同期機構を実装せずに、ゴールーチン間の処理タイミングを調整できます。
- 送受信の値自体は重要でない場合もあります（例では1を送っていますが、これは単なる信号です）。
- この方法は、`sync.WaitGroup`よりも柔軟で、より細かい制御が可能です。

チャネルのこの同期機能を理解し活用することで、並行処理のより効果的で読みやすい設計が可能になります。

## ゴールーチンでよくあるバグ
### 変数のスコープ問題
ゴールーチン内で外部のループ変数を参照すると、予期しない結果になることがあります。

```go
for i := 0; i < 3; i++ {
	go func() {
		fmt.Println(i)    
	}()
}
// 結果: 2, 2, 2 (順不同)
```

なぜこのバグが起こるのか

1. ループ変数 `i` は各イテレーションで上書きされます。
2. ゴールーチンは非同期で実行されるため、実行時にはループが既に終了している可能性があります。
3. そのため、全てのゴールーチンが最後の `i` の値（この場合は2）を参照してしまいます。

![[Pasted image 20241001132952.png]]

修正方法は、ゴールーチンに変数をパラメータとして渡すことで、各ゴールーチンが独自のコピーを持つようにします。

```go
for i := 0; i < 3; i++ {
	go func(i int) {
		fmt.Println(i)
	}(i)
}
// 結果: 0, 1, 2 (順不同)
```

重要なポイントは、

1. 変数のスコープに注意
	- ゴールーチン内で外部の変数を参照する際は、その変数のライフサイクルとスコープを慎重に考慮する必要があります。
2. 値の引き渡し
	- ゴールーチンに値を渡す際は、引数として渡すことで、その時点での値のコピーを確実に使用できます。
3. クロージャの理解
	- ゴールーチン内の無名関数（クロージャ）は、外部の変数を参照できますが、その参照のタイミングに注意が必要です。
4. 並行処理の非決定性
	- ゴールーチンの実行順序は保証されないため、値の参照タイミングに依存するコードは避けるべきです。
5. デバッグの難しさ
	- このような問題は、時と場合によって異なる挙動を示すため、デバッグが難しくなります。慎重なコード設計が重要です。

![[Pasted image 20241001184054.png]]

このような問題を避けることで、より信頼性の高い並行プログラムを作成することができます。
常にゴールーチン内で使用する変数のスコープとライフサイクルを意識することが大切です。

