# Goで並行処理(基本編)
## チャネルの性質と状態
チャネルは、その状態によって異なる挙動を示します。主な状態と挙動を以下にまとめます。

### チャネルの主な状態
チャネルと一言でいっても、その種類・状態には様々なものがあります。
1. nil チャネル
	- 宣言されただけで初期化されていないチャネル
	- 例：`var c chan int`
2. closed（閉じられた）チャネル
	- `close()`関数で閉じられたチャネル
3. バッファの状態
	- 空のバッファ
	- 値が入ったバッファ
	- 満杯のバッファ
4. 方向性
	- 送信専用チャネル
	- 受信専用チャネル
	- 双方向チャネル
### 状態に応じた挙動
#### a. nil チャネル
- 送信：ブロック（永遠に待機）
- 受信：ブロック（永遠に待機）
- close：パニック
#### b. open（開いている）チャネル
- 送信：バッファに空きがあれば成功、なければブロック
- 受信：値があれば成功、なければブロック
- close：成功（チャネルが閉じられる）
#### c. closed（閉じられた）チャネル
- 送信：パニック
- 受信：バッファに残っている値がある場合はそれを返す、ない場合はゼロ値を返す（ブロックしない）
- close：パニック

### 重要なポイント
- **nil チャネルは常にブロックされる**
	- nilチャネルに対する操作は永遠に待機状態になります。
	- これを利用して特定の操作を無効化することができます。
- **閉じられたチャネルは決してブロックされない**
	- 閉じられたチャネルからの受信は即座に完了します。
	- バッファに値が残っている場合はその値を、なければゼロ値を返します。
- **閉じられたチャネルへの送信はパニックを引き起こす**：
	- 閉じられたチャネルに値を送信しようとするとプログラムがクラッシュします。

これらの性質を理解することで、チャネルを使った並行プログラミングをより効果的に、そして安全に行うことができます。
特に、nilチャネルと閉じられたチャネルの挙動の違いは、プログラムの制御フローを設計する上で重要な要素となります。
## チャネルは同期の手段
チャネル、特にバッファなしチャネルは、データの送受信だけでなく、ゴールーチン間の同期にも使用されます。
これは非常に重要な概念です。

### バッファなしチャネルの同期機能
#### 送信側の挙動
- 受信側が準備できるまで、送信処理がブロックされます。
#### 受信側の挙動
- 送信側が値を送るまで、受信処理がブロックされます。
#### 同期のポイント
- 送信と受信が行われる瞬間が、ゴールーチン間の「待ち合わせ点」となります。

## 実際の例：ソート処理の完了を待つ
これを実感するためのいい例が[Effective Go](https://golang.org/doc/effective_go#channels)の中に存在します。
Effective Goからの例を簡単に説明すると

1. メインゴールーチン：
    - チャネルを作成します。
    - 別のゴールーチンでソート処理を開始します。
    - 他の作業（`doSomethingForAWhile()`）を行います。
    - チャネルからの受信を待ちます（`<-c`）。
2. ソート用ゴールーチン：
    - ソートを実行します。
    - 完了後、チャネルに値を送信します（`c <- 1`）。
3. 同期のポイント：
    - ソートゴールーチンが値を送信し、メインゴールーチンがその値を受信する瞬間。
    - この時点で、ソートの完了がメインゴールーチンに伝わります。

```go
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
	list.Sort()
	c <- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
<-c   // Wait for sort to finish; discard sent value.
```

### 重要なポイント

- チャネルを使うことで、複雑な同期機構を実装せずに、ゴールーチン間の処理タイミングを調整できます。
- 送受信の値自体は重要でない場合もあります（例では1を送っていますが、これは単なる信号です）。
- この方法は、`sync.WaitGroup`よりも柔軟で、より細かい制御が可能です。

チャネルのこの同期機能を理解し活用することで、並行処理のより効果的で読みやすい設計が可能になります。

## ゴールーチンでよくあるバグ
### 変数のスコープ問題
ゴールーチン内で外部のループ変数を参照すると、予期しない結果になることがあります。

```go
for i := 0; i < 3; i++ {
	go func() {
		fmt.Println(i)    
	}()
}
// 結果: 2, 2, 2 (順不同)
```

なぜこのバグが起こるのか

1. ループ変数 `i` は各イテレーションで上書きされます。
2. ゴールーチンは非同期で実行されるため、実行時にはループが既に終了している可能性があります。
3. そのため、全てのゴールーチンが最後の `i` の値（この場合は2）を参照してしまいます。

![[Pasted image 20241001132952.png]]

修正方法は、ゴールーチンに変数をパラメータとして渡すことで、各ゴールーチンが独自のコピーを持つようにします。

```go
for i := 0; i < 3; i++ {
	go func(i int) {
		fmt.Println(i)
	}(i)
}
// 結果: 0, 1, 2 (順不同)
```

重要なポイントは、

1. 変数のスコープに注意
	- ゴールーチン内で外部の変数を参照する際は、その変数のライフサイクルとスコープを慎重に考慮する必要があります。
2. 値の引き渡し
	- ゴールーチンに値を渡す際は、引数として渡すことで、その時点での値のコピーを確実に使用できます。
3. クロージャの理解
	- ゴールーチン内の無名関数（クロージャ）は、外部の変数を参照できますが、その参照のタイミングに注意が必要です。
4. 並行処理の非決定性
	- ゴールーチンの実行順序は保証されないため、値の参照タイミングに依存するコードは避けるべきです。
5. デバッグの難しさ
	- このような問題は、時と場合によって異なる挙動を示すため、デバッグが難しくなります。慎重なコード設計が重要です。

![[Pasted image 20241001184054.png]]

このような問題を避けることで、より信頼性の高い並行プログラムを作成することができます。
常にゴールーチン内で使用する変数のスコープとライフサイクルを意識することが大切です。

### ゴールーチンが実行されずにプログラムが終了する問題
メインゴールーチンが終了すると、他のゴールーチンの実行状態に関わらずプログラム全体が終了してしまいます。

```go
func getLuckyNum() {
	// (前略)
	num := rand.Intn(10)
	fmt.Printf("Today's your lucky number is %d!\n", num)
}

func main() {
	fmt.Println("what is today's lucky number?")
	go getLuckyNum()
}

// 結果: ラッキーナンバーが表示されない
```

なぜこのバグが起こるのか

1. ゴールーチンは非同期で実行されます。
2. メインゴールーチンは他のゴールーチンの完了を待たずに終了します。
3. メインゴールーチンが終了すると、プログラム全体が終了し、他のゴールーチンも強制終了されます。

修正方法は、ゴールーチンの完了を待つ仕組みを実装する必要があります。
主に2つの方法があります。
#### `sync.WaitGroup` を使用する方法

```go
func main() {
	fmt.Println("what is today's lucky number?")

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		getLuckyNum()
	}()

	wg.Wait()
}
```

#### チャネルを使用する方法

```go
func getLuckyNum(c chan<- int) {
	// (前略)
	num := rand.Intn(10)
	c <- num
}

func main() {
	fmt.Println("what is today's lucky number?")

	c := make(chan int)
	go getLuckyNum(c)

	num := <-c
}
```

### 重要なポイント

#### ゴールーチンの寿命管理
ゴールーチンを起動したら、その完了を適切に管理する必要があります。
#### 同期メカニズムの選択
`sync.WaitGroup` とチャネルは異なる使用シーンに適しています。

- `sync.WaitGroup`: 複数のゴールーチンの完了を待つ場合に便利。
- チャネル: ゴールーチン間でデータを受け渡す必要がある場合に適している。
#### プログラムの終了条件
メインゴールーチンが終了するタイミングを慎重に制御する必要があります。
#### リソース管理
ゴールーチンが必要以上に長く実行されないよう、適切なタイムアウト処理も考慮すべきです。
#### デバッグの難しさ
このような問題は、特定の条件下でのみ発生する可能性があり、再現が難しい場合があります。

これらのポイントを意識することで、ゴールーチンを適切に管理し、意図した通りの並行処理を実現できます。ゴールーチンの使用には常に「どのように終了させるか」を考慮することが重要です。

### データ競合（Race Condition）の問題
複数のゴールーチンが同時に共有データにアクセスすると、予期しない結果や不整合が発生することがあります。

```go
func main() {
	src := []int{1, 2, 3, 4, 5}
	dst := []int{}

	// srcの要素毎にある何か処理をして、結果をdstにいれる
	for _, s := range src {
		go func(s int) {
			// 何か(重い)処理をする
			result := s * 2

			// 結果をdstにいれる
			dst = append(dst, result)
		}(s)
	}

	time.Sleep(time.Second)
	fmt.Println(dst)
}
```

なぜこのバグが起こるのか

1. 複数のゴールーチンが同時に `dst` スライスを読み書きしています。
2. `append` 操作は原子的（アトミック）ではありません。
3. あるゴールーチンの更新が他のゴールーチンの更新によって上書きされる可能性があります。

修正方法は、データ競合を解決するには主に3つの方法があります。

#### チャネルを使用する
ゴールーチン間で値(今回は`dst`スライスの中身)をやり取りする場合には、チャネルを使うのが一番安全です。
チャネルを使って上記の処理を書き換えるのならば、例えば以下のようになります。

```go
func main() {
	src := []int{1, 2, 3, 4, 5}
	dst := []int{}

	c := make(chan int)

	for _, s := range src {
		go func(s int, c chan int) {
			result := s * 2
			c <- result
		}(s, c)
	}

	for _ = range src {
		num := <-c
		dst = append(dst, num)
	}

	fmt.Println(dst)
	close(c)
}
```

#### 並行処理を避ける
また、並行にしなかったとしてもパフォーマンスに影響が少なそうなのであれば、「そもそも並行処理にしない」という手もあります。

```go
func main() {
	src := []int{1, 2, 3, 4, 5}
	dst := []int{}

	// srcの要素毎にある何か処理をして、結果をdstにいれる
	for _, s := range src {
	// 何か(重い)処理をする
	result := s * 2

	// 結果をdstにいれる
	dst = append(dst, result)
	}

	fmt.Println(dst)
}
```

#### 排他制御（Mutex）を使用する

```go
func main() {
	src := []int{1, 2, 3, 4, 5}
	dst := []int{}

	var mu sync.Mutex

	for _, s := range src {
		go func(s int) {
			result := s * 2
			mu.Lock()
			dst = append(dst, result)
			mu.Unlock()
		}(s)
	}

	time.Sleep(time.Second)
	fmt.Println(dst)
}
```

### 重要なポイント
#### データ共有の危険性
複数のゴールーチンで共有データを扱う際は常に注意が必要です。
#### チャネルの推奨
Goでは、ゴールーチン間の通信にはチャネルの使用が推奨されています。
#### Mutexの適切な使用
Mutexは低レベルの同期機構で、使用には注意が必要です。可能な限りチャネルを使用しましょう。
#### 並行処理の必要性の検討
並行処理が本当に必要かどうか、パフォーマンス面で利点があるかを確認しましょう。
#### デバッグの難しさ
データ競合は再現が難しく、デバッグが困難な場合があります。
#### Go のツール活用
Go には `go vet` や `-race` フラグなど、データ競合を検出するツールがあります。積極的に活用しましょう。

これらのポイントを意識することで、データ競合を回避し、より安全で効率的な並行プログラムを作成できます。チャネルを中心とした設計を心がけ、必要な場合にのみ低レベルの同期機構を使用するようにしましょう。