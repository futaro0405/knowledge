
```js:src/containers/Restaurants.jsx
import { Link } from "react-router-dom";
// components
import Skeleton from '@material-ui/lab/Skeleton';
// styled-componentsのスタイリング部分
const RestaurantsContentsList = styled.div`
  display: flex;
  justify-content: space-around;
  margin-bottom: 150px;
`;
const RestaurantsContentWrapper = styled.div`
  width: 450px;
  height: 300px;
  padding: 48px;
`;
const RestaurantsImageNode = styled.img`
  width: 100%;
`;
const MainText = styled.p`
  color: black;
  font-size: 18px;
`;
const SubText = styled.p`
  color: black;
  font-size: 12px;
`;
<RestaurantsContentsList>
  {
    state.fetchState === REQUEST_STATE.LOADING ?
      <Fragment>
        <Skeleton variant="rect" width={450} height={300} />
        <Skeleton variant="rect" width={450} height={300} />
        <Skeleton variant="rect" width={450} height={300} />
      </Fragment>
    :
      state.restaurantsList.map((item, index) =>
        <Link to={`/restaurants/${item.id}/foods`} key={index} style={{ textDecoration: 'none' }}>
          <RestaurantsContentWrapper>
            <RestaurantsImageNode src={RestaurantImage} />
            <MainText>{item.name}</MainText>
            <SubText>{`配送料：${item.fee}円 ${item.time_required}分`}</SubText>
          </RestaurantsContentWrapper>
        </Link>
      )
  }
</RestaurantsContentsList>
```

#### Linkについて
React Routerの`<Link>`について。
React Routerにおけるルーティングは通常のリンク(`<a href="...">`)とは異なり、`<Link to="...">`というかたちで表される。
最終的には`<a>`タグが生成されるという点では同じ。

例えば今回のように
- 現在のURL：`/restaurants`
- 遷移先URL：`/restaurants/1/foods`
としたい場合に、
```js
<Link to={`/restaurants/1/foods`}>
```
とすることで、
```js
<a href="restaurants/1/foods">
```
となるわけです。
クエリストリングを付けることも可能で、以下のようなpropsを渡すことで対応した`<a>`に変換する。
```js
<Link
  to={{
    pathname: "/courses",
    search: "?sort=name",
    hash: "#the-hash"
  }}
/>
```
#### Skeltonコンポーネントについて
Material UIというUIライブラリのコンポーネント。
「ロード状態」を表すUIパーツ。
## フード一覧のAPIを叩く
```js:src/apis/foods.js
import axios from 'axios';
import { foodsIndex } from '../urls/index'

export const fetchFoods =(restaurantId) => {
  return axios.get(foodsIndex(restaurantId))
  .then(res => {
    return res.data
  })
  .catch((e) => console.error(e))
}
```

```js
import { Fragment, useEffect } from 'react';

import { fetchFoods } from '../apis/foods';

export const Foods = () => {
  useEffect(() => {
    fetchFoods(1)
    .then((data) =>
      console.log(data)
    )
  }, [])
  return (
    <Fragment>
      フード一覧
    </Fragment>
  )
}
```

## APIのデータをreducerを通して画面に表示する
### src/reducers/foods.js

```js:src/reducers/foods.js
import { REQUEST_STATE } from '../constants';

export const initialState = {
  fetchState: REQUEST_STATE.INITIAL,
  foodsList: [],
};

export const foodsActionTyps = {
  FETCHING: 'FETCHING',
  FETCH_SUCCESS: 'FETCH_SUCCESS'
}

export const foodsReducer = (state, action) => {
  switch (action.type) {
    case foodsActionTyps.FETCHING:
      return {
        ...state,
        fetchState: REQUEST_STATE.LOADING,
      };
    case foodsActionTyps.FETCH_SUCCESS:
      return {
        fetchState: REQUEST_STATE.OK,
        foodsList: action.payload.foods,
      };
    default:
      throw new Error();
  }
}
```

```js:src/containers/Foods.jsx
import { Fragment, useEffect, useReducer } from 'react';

// reducers
import {
  initialState as foodsInitialState,
  foodsActionTyps,
  foodsReducer,
} from '../reducers/foods';

// apis
import { fetchFoods } from '../apis/foods';

// constants
import { REQUEST_STATE } from '../constants';

export const Foods = ({
  match
}) => {
  const [foodsState, dispatch] = useReducer(foodsReducer, foodsInitialState);

  useEffect(() => {
    dispatch({ type: foodsActionTyps.FETCHING });
    fetchFoods(match.params.restaurantsId)
      .then((data) => {
        dispatch({
          type: foodsActionTyps.FETCH_SUCCESS,
          payload: {
            foods: data.foods
          }
        });
      })
  }, [])

  return (
    <Fragment>
      {
        foodsState.fetchState === REQUEST_STATE.LOADING ?
          <Fragment>
            <p>
              ロード中...
            </p>
          </Fragment>
        :
          foodsState.foodsList.map(food =>
            <div key={food.id}>
              {food.name}
            </div>
          )
      }
    </Fragment>
  )
}
```

## フード一覧ページにスタイルをあてる
### アイコン一覧のファイルを作る

src/components/Icons/index.js
```js:src/components/Icons/index.js
export { default as LocalMallIcon } from '@material-ui/icons/LocalMall';
export { default as QueryBuilderIcon } from '@material-ui/icons/QueryBuilder';
```

### ヘッダー、オーダーページへのリンクアイコン

src/containers/Foods.jsx
```js:src/containers/Foods.jsx
import styled from 'styled-components';

import { COLORS } from '../style_constants';
import { LocalMallIcon } from '../components/Icons';

const HeaderWrapper = styled.div`
  display: flex;
  justify-content: space-between;
  padding: 8px 32px;
`;

const BagIconWrapper = styled.div`
  padding-top: 24px;
`;

const ColoredBagIcon = styled(LocalMallIcon)`
  color: ${COLORS.MAIN};
`;
```

### フード一覧

src/components/StyledText.jsx
```js:src/components/StyledText.jsx
import styled from 'styled-components';
import { COLORS, FONT_SIZE } from '../style_constants';

export const SubText = styled.p`
  color: ${COLORS.SUB_TEXT};
  font-size: ${FONT_SIZE.BODY2};
`;
```

src/components/FoodWrapper.jsx
```js:src/components/FoodWrapper.jsx
import React from 'react';
import styled from 'styled-components';

// components
import { SubText } from './StyledText';

// constants
import { COLORS } from '../style_constants';

const Wrapper = styled.div`
  display: flex;
  width: 450px;
  height: 180px;
  border-width: 1px;
  border-style: solid;
  border-color: ${COLORS.BORDER};
  border-image: initial;
  cursor: pointer;
`;

const FoodDetail = styled.div`
  padding: 24px 16px;
  width: 250px;
`;

const DescriptionWrapper = styled.div`
  height: 75px;
`

const PriceWrapper = styled.div`
  margin-top: 16px;
`

const FoodImageNode = styled.img`
  width: 250px;
`;

export const FoodWrapper = ({
  food,
  onClickFoodWrapper,
  imageUrl,
}) => (
  <Wrapper onClick={() => onClickFoodWrapper(food)}>
    <FoodDetail>
      {food.name}
      <DescriptionWrapper>
        <SubText>
          {food.description}
        </SubText>
      </DescriptionWrapper>
      <PriceWrapper>
        ¥{food.price}
      </PriceWrapper>
    </FoodDetail>
    <FoodImageNode src={imageUrl} />
  </Wrapper>
)
```

#### コンポーネント設計のポイント
**コンポーネントの関心ごととしては、フードの情報を表示し、渡されたonClickFoodWrapperを実行する**だけ。
つまり、ここにはstateは一切ありません。

使いまわされるコンポーネントをPresentational Componentとすれば、ここに複雑なロジックやstateを保持すべきではありません。渡されたpropsを描画したり、`onClickFoodWrapper`を実行するだけに止めるべきです。そうすることで、親コンポーネントで「どのようなfoodを渡すか」「onClickFoodWrapperの結果、リンクなのか、モーダルを開くのか」を決めることができます。

もしこれから自分で作るReactコンポーネントにstateが複数にまたがっていたり、子コンポーネントに複雑なロジックが定義されていたりしたら少し立ち止まって考えるようにしましょう。もちろん常にアンチパターン(良くない設計)というわけでもないので、積極的な理由がない限りPresentational Componentにstateを持たせるのは避けた方がいいと思います。

### コンポーネントを使ってスタイルをあてる

src/containers/Foods.jsx
```js:src/containers/Foods.jsx

import { FoodWrapper } from '../components/FoodWrapper';
import Skeleton from '@material-ui/lab/Skeleton';


// images
import MainLogo from '../images/logo.png';
import FoodImage from '../images/food-image.jpg';


const MainLogoImage = styled.img`
  height: 90px;
`

const FoodsList = styled.div`
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
  margin-bottom: 50px;
`;

const ItemWrapper = styled.div`
  margin: 16px;
`;


export const Foods = ({
  match
}) => {

  return (
    <Fragment>
      <HeaderWrapper>
        <Link to="/restaurants">
          <MainLogoImage src={MainLogo} alt="main logo" />
        </Link>
        <BagIconWrapper>
          <Link to="/orders">
            <ColoredBagIcon fontSize="large" />
          </Link>
        </BagIconWrapper>
      </HeaderWrapper>
      <FoodsList>
        {
          foodsState.fetchState === REQUEST_STATE.LOADING ?
            <Fragment>
              {
                [...Array(12).keys()].map(i =>
                  <ItemWrapper key={i}>
                    <Skeleton key={i} variant="rect" width={450} height={180} />
                  </ItemWrapper>
                )
              }
            </Fragment>
          :
            foodsState.foodsList.map(food =>
              <ItemWrapper key={food.id}>
                <FoodWrapper
                  food={food}
                  onClickFoodWrapper={(food) => console.log(food)}
                  imageUrl={FoodImage}
                />
              </ItemWrapper>
            )
        }
      </FoodsList>
    </Fragment>
  )
}
```

## 注文モーダルを実装する
今回はstateは２つ以上ある。

```js
const [state, setState] = useState({
  isOpenOrderDialog: false,
  selectedFood: null
})
```

つまり、stateにオブジェクトを入れる方法です。
もちろん以下のようにすることも可能です。

```js
const [isOpenOrderDialog, setIsOpenOrderDialog] = useState(false)
const [selectedFood, setSelectedFood] = useState(null)
```

ただし、このようにstateを分割すると１コンポーネント内で多くのstateがある場合に不便なので、今回は１つのオブジェクトとして管理してみます。

そして、こうすることでフードitemがクリックされた場合にこのような処理を入れれば良さそうです。

```js
const [state, setState] = useState({
  isOpenOrderDialog: false,
  selectedFood: null
})

// foodはクリックされたフードitemを期待します
const clickFoodItem = (food) => {
  setState({
    isOpenOrderDialog: true,
    selectedFood: food,
  })
}

// 関数を呼ぶ側
clickFoodItem(food);
```

### useStateを使ってモーダルを開閉する
以上をふまえて、まずは`useState`で使うstateを定義していきます。

src/containers/Foods.jsx
```js:src/containers/Foods.jsx
// useStateを新たにimport
import React, { Fragment, useReducer, useEffect, useState } from 'react';

const [foodsState, dispatch] = useReducer(foodsReducer, foodsInitialState);
const initialState = {
    isOpenOrderDialog: false,
    selectedFood: null,
    selectedFoodCount: 1,
}
const [state, setState] = useState(initialState);
```

`selectedFoodCount`を追加。
これは`selectedFood`がいくつ選ばれているか？という数量を表す値です。

フードitemをクリックしたらモーダルを開く、つまり`isOpenOrderDialog: true`にする。
ということは、「フードitemをクリックする」というところにこの`setState()`を渡せば良さそう。

これは、前パートで実装した`FoodWrapper`がそれにあたります。

src/containers/Foods.jsx
```js:src/containers/Foods.jsx
<FoodWrapper
  food={food}
  onClickFoodWrapper={
    (food) => setState({
      ...state,
      isOpenOrderDialog: true,
      selectedFood: food,
    })
  }
  imageUrl={FoodImage}
/>
```

`onClickFoodWrapper`の部分をみてみると、`setState()`が渡されています。
こうすることで、`FoodWrapper`の中でフードitemがクリックされた場合に`setState()`が実行されます。
親コンポーネント`Foods`からは`setState()`を子コンポーネント`FoodWrapper`に対してpropsとして渡します。
受け取った`FoodWrapper`側は`onClickFoodWrapper`という名前で受け取ります。
そして、その`onClickFoodWrapper`関数はフードitemがクリックされた時に実行されるので、実際は渡された元となる`setState()`が実行されるというわけです。

#### コンポーネントのデータの"方向
コンポーネント設計として基本的にアクションの向きは「子コンポーネント => 親コンポーネント」となるべき。
今回の例でいえば、親から子へprops経由で関数を渡すだけ。
そして子ではその関数を実行するだけ。
そうすると、子=>親へと関数が伝播する。

これが逆向きが混在すると厄介。
親コンポーネントから子コンポーネントを操作するようなイメージ。
Reactでも`ref`を使うことで実現はできますが、多用することは推奨されていません。
例えば、子コンポーネントがstateを持っていて、それを親コンポーネントから操作(フラグをtrue => falseにするなど)するイメージです。

ここでは、親から子へ関数をpropsとして渡して、子ではそれを実行するだけ、と覚えておけばいいかと思います。



さて、これだけでは`setState()`しただけでモーダルはもちろん表示されません。
Material UIの`Dialog`コンポーネントを別コンポーネントとして定義し、それを表示させてみましょう。

src/components/FoodOrderDialog.jsx
```js:src/components/FoodOrderDialog.jsx
import React from 'react';
import { DialogContent, Dialog, DialogTitle, DialogActions } from '@material-ui/core';
import styled from 'styled-components';

// components
import { SubText } from './StyledText';

// images
import OrderHeaderImage from '../images/order-header.png';

const OrderHeader = styled.img`
  width: 100%;
  height: 350px;
`;

const DescriptionWrapper = styled.div`
  padding: 0 8px 8px 8px;
  height: 50px;
`;

export const FoodOrderDialog = ({
  food,
  isOpen,
  onClose,
}) => {
  return (
    <Dialog
      open={isOpen}
      onClose={onClose}
    >
      <OrderHeader src={OrderHeaderImage} alt="order header" />
      <DialogTitle>
        {food.name}
      </DialogTitle>
      <DialogContent>
        <DescriptionWrapper>
          <SubText>
            {food.description}
          </SubText>
        </DescriptionWrapper>
      </DialogContent>
      <DialogActions>
      </DialogActions>
    </Dialog>
  )
}
```

Material UIの`Dialog`は最低２つのprops。
１つが`open`でboolean値。
もう一つが`onClose`で、こちらは関数を受け取ります。
モーダルを閉じるために行う関数です。
先ほどの例で言えば、`setState({...state, isOpenOrderDialog: false})`をここに渡すことで、モーダルが閉じようとする時にこの関数を実行してくれます。
そして結果的にstateは更新され、モーダルは無事閉じることができるという流れです。

もう一つ特徴としては`Dialog`コンポーネントはその中に`DialogTitle`や`DialogContent`などのMaterial UI提供のラッパーコンポーネントを含めることで、"それらしい"スタイルで描画してくれます。

src/containers/Foods.jsx
```js:src/containers/Foods.jsx
// useStateを新たにimport
import React, { Fragment, useReducer, useEffect, useState } from 'react';

// --- ここから追加 ---
import { FoodOrderDialog } from '../components/FoodOrderDialog';
// --- ここまで追加 ---

export const Foods = ({
  match
}) => {

  // --- ここから追加 ---
  const initialState = {
    isOpenOrderDialog: false,
    selectedFood: null,
    selectedFoodCount: 1,
  }
  const [state, setState] = useState(initialState);
  // --- ここまで追加 ---

  return (
    <Fragment>

	// --- ここから追加 ---
      {
        state.isOpenOrderDialog &&
          <FoodOrderDialog
            food={state.selectedFood}
            isOpen={state.isOpenOrderDialog}
            onClose={() => setState({
              ...state,
              isOpenOrderDialog: false,
            })}
          />
      }
      // --- ここまで追加 ---

    </Fragment>
  )
}
```

`&&`より前の値がtrueの場合に、`&&`よりあとの要素をレンダリングするようJSXが認識します。
つまり上記の例の場合、`state.isOpenOrderDialog`がtrueの場合に`FoodOrderDialog`コンポーネントをレンダリングしてくれるようになります。

### 基底スタイルを定義する
これまで`/components`ディレクトリに子コンポーネントは作ってきました。
しかし、それらの子コンポーネント間でベースとなるスタイルが必要な場合どうすればいいでしょうか？

CSSがあればスタイルシートにCSSを定義して、子コンポーネントに`class`を与えれば済みました。
しかし、CSS in JSの場合はそれはできません。
ということで、まず試しにコンポーネント間で使える基底スタイルをもったファイルを作ります。
要は共通のstyled-componentsです。

