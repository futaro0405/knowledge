# ルーティング
## クライアントサイドとサーバーサイドのルーティングの比較
### サーバーサイドのルーティング
- ユーザーがアクセスするURLのパスに基づいて、サーバーがレスポンスを送信します。
- 従来のサーバーレンダリングのWebアプリでリンクをクリックすると、ブラウザーはサーバーから新しいHTMLレスポンスを受け取り、ページ全体を再読み込みします。
### クライアントサイドのルーティング
- クライアントサイドのJavaScriptがナビゲーションを横取りし、動的に新しいデータを取得して現在のページを更新します。ページ全体を再読み込みする必要がありません。
- 特にSingle-Page Application（SPA）で使用されます。
- クライアントサイドのルーターは、History APIやhashchangeイベントなどのブラウザーAPIを使用して、アプリケーションのレンダリングビューを管理します。
## サーバーサイドのルーティングの流れ
1. **リンククリック**
	- ユーザーがリンクをクリックすると、ブラウザーがそのリンクのURLに対してリクエストを送信します。
2. **サーバーレスポンス**
    - サーバーはリクエストされたURLに基づいて新しいHTMLページを生成し、ブラウザーに送信します。
3. **ページ再読み込み**
    - ブラウザーは新しいHTMLページを受け取り、現在のページを新しいHTMLで置き換えます。
### クライアントサイドのルーティングの流れ
1. **リンククリック**
    - ユーザーがリンクをクリックすると、クライアントサイドのJavaScriptがそのイベントをキャッチします。
2. **JavaScript処理**
	- JavaScriptが動的に新しいデータを取得し、必要に応じてDOMを更新します。
3. **ページ更新**
	- ページ全体を再読み込みすることなく、現在のページの一部を更新します。
### クライアントサイドルーティングの利点
- **高速なユーザーエクスペリエンス**
    - ページ全体の再読み込みが不要なため、ナビゲーションが迅速になります。
    - 特に、ユーザーが多くのインタラクションを実行するようなアプリケーションで効果的です。
- **スムーズなナビゲーション**
    - ページの一部のみが更新されるため、ユーザーエクスペリエンスが向上します。
### クライアントサイドルーティングの実装
- **History API**
    - `pushState`や`replaceState`を使用してURLを変更し、ページの再読み込みを行わずに状態を管理します。
- **hashchange イベント**
    - URLのハッシュ部分（`#`以降）を変更することで、ナビゲーションを行います。

```js
// History APIを使った例
window.history.pushState({}, '', '/new-page');

// hashchange イベントを使った例
window.location.hash = '#new-section';
```

これにより、ユーザーが新しいページに移動したかのような効果を得ることができますが、実際にはページ全体が再読み込みされることなく、新しいコンテンツが表示されます。
## 公式ルーター
Vue は SPA の構築に適しています。ほとんどの SPA では、公式がサポートする [Vue Router ライブラリー](https://github.com/vuejs/router) を使うことを推奨します。
詳細は、Vue Router の [ドキュメント](https://router.vuejs.org/) を参照してください。

