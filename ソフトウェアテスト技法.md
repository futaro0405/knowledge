## ソフトウェアテスト技法とは
なるべく少ないテストケースでなるべく多くのバグを発見するための技術
### 同値クラステストと境界値テスト
#### 同値クラステスト
同値クラスとは、__同じ動作をする条件の集まり__ として定義される。
各同値クラスから最低限1つの代表値を用いてテストを行う技法を __同値クラステスト__ と呼ぶ。

#### 境界値テスト
境界値テストは、__仕様条件の境界の値とその隣の値に対してテストを行う技法__ 。
境界付近にバグが潜んでいる可能性は高いため重要なテスト。
テストする値のパターンは以下3パターン
- 境界値
- 境界値の1つ上
- 境界値の1つ下

### ドメイン分析テストとデシジョンテーブル
#### ドメイン分析テスト
条件同士が相互作用を持つような場合
言い換えるなら、複雑な条件が数式で結ばれている場合に有効

offポイントはonポイントがドメイン内ならドメイン外の隣接する値、
onポイントがドメイン外ならドメイン内の隣接する値にする

| ポイント名 | 概要                           | x >= 10 の場合 | x > 10 の場合 |
| ---------- | ------------------------------ | -------------- | ------------- |
| on         | 境界上の値                     | 10             | 10            |
| off        | 境界上にはない境界に隣接する値 | 9              | 11            |
| in         | on/off以外のドメイン内側の値   | 15など         | 15など        |
| out        | on/off以外のドメイン外側の値   | 5など          | 5など         |
 
#### デシジョンテーブル
条件同士は独立していて、込み入った論理関係を整理する場合
言い換えるなら、複数の条件が論理式で結ばれている場合に有効

「書籍を購入している AND 4000円以上購入している AND 離島に住んでいない」
このケースをデシジョンテーブルで表現すると以下のようになる

表：デシジョンテーブル

|                        | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ---------------------- | --- | --- | --- | --- | --- | --- | --- | --- |
| 条件                   |     |     |     |     |     |     |     |     |
| 書籍を購入している     | Yes | Yes | Yes | No  | Yes | No  | No  | No  |
| 4000円以上購入している | Yes | Yes | No  | Yes | No  | Yes | No  | No  |
| 離島に住んでいない     | Yes | No  | Yes | Yes | No  | No  | Yes | No  |
| アクション             |     |     |     |     |     |     |     |     |
| 送料無料               | Yes | No  | No  | No  | No  | No  | No  | No  |

条件とその時の結果をそれぞれ埋めていくことで書くことができる
場合によって網羅性を維持しつつ、デシジョンテーブルを圧縮することができる
条件分岐の順番が判明している、かつ順番が一定なら圧縮可能

|                        | 1   | 2   | 3   | 4   |
| ---------------------- | --- | --- | --- | --- |
| 条件                   |     |     |     |     |
| 書籍を購入している     | Yes | Yes | Yes | No  |
| 4000円以上購入している | Yes | Yes | No  | -   |
| 離島に住んでいない     | Yes | No  | -   | -   |
| アクション             |     |     |     |     |
| 送料無料               | Yes | No  | No  | No  |

さらに条件が増えた場合、テストケースが膨大になる
全てを網羅することは諦め、少ないテストケースである程度の網羅性を確保するための技法がペア構成テスト

### ペア構成テスト（直公表）
#### ペア構成テスト
すべての条件のすべての組み合わせをテストするのではなく、条件のすべてのペアをテストする技法

すべてのペアとは？
例：2値条件（0/1）が3つ（条件A, B, C）ある場合
すべての組み合わせ → 8通りだが
すべてのペア →「AとB」「AとC」「BとC」という3通りの条件の組み合わせそれぞれに、「0, 0」「0, 1」「1, 0」「1, 1」の4通りの値

すべてのペアをテストすることである程度の網羅性が確保できる理由は？
ほとんどの欠陥はシングルモード欠陥とダブルモード欠陥のどちらか
シングルモード欠陥 → モジュールが正しく動かない欠陥
ダブルモード欠陥 → 2つのモジュールが組み合わさったときに生じる欠陥

すべてのペアを調べれば、シングルモード欠陥とダブルモード欠陥については網羅できることになるので、ある程度の網羅性を確保できる
ペア構成テストによって70~85%程度のバグを発見することが期待できる
これを見ただけだとすべてのペアを調べるほうが大変そうに思えるが、すべてのペアを調べるとテストケースが大幅に減ることを __直交表__ で確認しよう

#### 直交表
すべてのペアを抜けもれなく網羅する方法のひとつ
「2値条件（0/1）が3つ（条件A, B, C）ある場合」を直交表で書くと以下

表：直交表（2値条件が3つ） 

|     | A   | B   | C   |
| --- | --- | --- | --- |
| 1   | 0   | 0   | 0   |
| 2   | 0   | 1   | 1   |
| 3   | 1   | 0   | 1   |
| 4   | 1   | 1   | 0   |

直交表を使うと行がテストケースになり、直交表で作られたテストケースを使えばすべてのペアを網羅することができる
直交表の中にはすべての条件のペアにおいて「0, 0」「0, 1」「1, 0」「1, 1」が現れていることと、テストケースが4つまで減っていることに注目

「3値条件が4つある場合」は以下のような直交表になる
表：直交表（3値条件が4つ） 

|     | A   | B   | C   | D   |
| --- | --- | --- | --- | --- |
| 1   | 0   | 0   | 0   | 0   |
| 2   | 0   | 1   | 1   | 1   |
| 3   | 0   | 2   | 2   | 2   |
| 4   | 1   | 0   | 1   | 2   |
| 5   | 1   | 1   | 2   | 0   |
| 6   | 1   | 2   | 0   | 1   |
| 7   | 2   | 0   | 2   | 1   |
| 8   | 2   | 1   | 0   | 2   |
| 9   | 2   | 2   | 1   | 0   |

すべての組み合わせは3の4乗で81通りあるのに対して、すべてのペアは直交表を使えば9通りのテストケースでテストできる

この場合でも「0,0」「0,1」「0,2」「1,0」「1,1」「1,2」「2,0」「2,1」「2,2」が すべてのペアにおいて現れていることに注目
このように直交表を使えばすべてのペアを少ないテストケースで網羅できる
⇒直交表を使えるようになろう！

直交表は自分でつくるものではない
すでにあるものの中から目的に応じて適切な直交表を選ぶのがテスト実行者の仕事
適切な直交表を選ぶためには、直交表の表記法を知る必要がある

表：L4(2^3)直交表（2値条件が3つ）

|     | A   | B   | C   |
| --- | --- | --- | --- |
| 1   | 0   | 0   | 0   |
| 2   | 0   | 1   | 1   |
| 3   | 1   | 0   | 1   |
| 4   | 1   | 1   | 0    |


上の直交表は4行で2値条件が3つなので「L4(2^3)」と表現する

### 状態遷移テスト
現在の状態とその遷移によって振る舞いが変わるようなソフトウェアをテストするための技法
状態遷移テストは目的に応じて2種類ある
簡単に全体を確認する __状態遷移図__
深く詳細を確認する __状態遷移表__

#### 状態遷移図
以下のような仕様のストップウォッチについて考える
- 初期状態でスタートボタンを押すとストップウォッチが動き出す
- 動いているときにスタートボタンを押すと停止する
- 停止しているときにスタートボタンを押すと再び動き出す
- 停止しているときにリセットボタンを押すと初期状態になる

このような仕様があったとき、状態遷移図で表現すると以下のようになる
![[Pasted image 20240515173153.png]]

- 状態遷移は大きく __状態__、__遷移__、__イベント__ の3つからなる
- 「イベント」は状態を遷移させるもののこと
- 初期状態は黒丸（●）、終了状態は目玉印（◉）で表現する

動作中にリセットボタンを押すなど、仕様にないケースのテストは未完了
仕様にはないが実際にはそのような操作をされる可能性はあるので対策が必要
ある状態でイベントが適用不可のことを __N/A（Not Applicable）__ と呼ぶ

状態遷移図は簡単な書き方で状態遷移の全体感を把握するのには便利だが、N/Aも含めて抜けもれなくテストケースを見出すのには向いていない。
状態遷移表を使って網羅的に検討する必要がある。

#### 状態遷移表

ストップウォッチの状態遷移表は以下のようになる
列の状態で行のイベントが起きたときの、遷移先の状態がセルに入っている

表：ストップウォッチの状態遷移表

| イベント/状態  | ①初期状態 | ②動作中 | ③停止中 |
| -------------- | --------- | ------- | ------- |
| スタートボタン | ②         | ③       | ②       |
| リセットボタン | N/A       | N/A     | ①       |

今回はいかなる状態でもリセットボタンが押されたら初期状態に戻る仕様とする

表：仕様変更後の状態遷移表

| イベント/状態  | ①初期状態 | ②動作中 | ③停止中 |
| -------------- | --------- | ------- | ------- |
| スタートボタン | ②         | ③       | ②       |
| リセットボタン | ①         | ①       | ①       |

状態遷移図も修正すると以下のようになる

![[Pasted image 20240515174335.png]]

「停止中」→「初期状態」→「動作中」という遷移のテストはできていない
__Nスイッチカバレッジ__ のテストを行う

#### Nスイッチカバレッジ
Nスイッチカバレッジのテストを実施するには、以下のように状態遷移表を前状態（行）×後状態（列）の関係行列の形に書き直す必要がある

スタートボタンをS、リセットボタンをRで表現している

表：関係行列

| 前状態/後状態 | ①初期状態 | ②動作中 | ③停止中 |
| ------------- | --------- | ------- | ------- |
| ①初期状態     | R         | S       |         |
| ②動作中       | R         |         | S       |
| ③停止中       | R         | S       |         |

表：1スイッチカバレッジ

| 前状態/後状態 | ①初期状態 | ②動作中 | ③停止中 |
| ------------- | --------- | ------- | ------- |
| ①初期状態     | RR+SR     | RS      | SS      |
| ②動作中       | RR+SR     | RS+SS   |         |
| ③停止中       | RR+SR     | RS      | SS      |

①×②セルのRSは、①初期状態の状態のときにリセットボタン（R）を押して、さらにスタートボタン（S）を押すと、②動作中の状態になるという意味

「停止中」→「初期状態」→「動作中」というように、前状態から後状態までに経由する状態（スイッチ）が1つなので、このような表を __1スイッチカバレッジ__ という
スイッチが2つなら2スイッチカバレッジ、N個なら __Nスイッチカバレッジ__ になる
スイッチの数Nに対して、関係行列をN+1乗することで __Nスイッチカバレッジ__ の表が得られる

#### カバレッジ
ここまで「なるべく少ないテストケースでなるべく多くのバグを発見する」ようなテストケースの作成方法である、ソフトウェアテスト技法について学んできた
テストケースを用意するためのその他の観点として「カバレッジ」がある

カバレッジは、ホワイトボックステストの考え方に基づいている
- ブラックボックステストとホワイトボックステスト
- ソフトウェアテストはテストケースの作り方によって大きく2種類に分かれる

##### ブラックボックステスト
ソフトウェアのコード内部のロジックを考慮せず、外部から見たときの仕様のみからテストケースを作成する
プログラミングの知識よりも業務に関する知識が必要

##### ホワイトボックステスト
コード内部のロジックを考慮してテストケースを作成する
ロジックなどを読み取れる必要があるので、ある程度プログラミングの知識が必要

#### データフローテストと制御フローテスト
ホワイトボックステストは、データフローテストと制御フローテストに分類される

##### データフローテスト
それぞれの変数において「生成->使用->廃棄」というサイクルを確認するテスト

- 変数を生成していないが使用しようとしている
- 生成しているのに使用していない など

##### 制御フローテスト
コード中の処理がどれだけ実効せれたかを基準に行うテスト
カバレッジは制御フローテストの考え方

### カバレッジとは
テスト可能なコードのうち、実際にテストされたコードの割合

代表的な5つのカバレッジレベルがある
- ステートメントカバレッジ
- デシジョンカバレッジ
- コンディションカバレッジ
- 複合コンディションカバレッジ
- MC/DCカバレッジ

#### レベル1:命令網羅（statement coverage）
実行可能な行のうち何行実行したかで求められるカバレッジレベル
`C0`とも表記される

ステートメントカバレッジの網羅率（%）
=実行した行数+実行可能な行数*100

#### レベル2:判定網羅（decision coverage）
判定の分岐をどれだけ網羅したかで求められるカバレッジレベル
__分岐網羅（branch coverage）__ とも呼ばれる。
または、`C1`と表記される

デシジョンカバレッジの網羅率（%）
=実現した判定結果の数/すべての判定の判定結果の合計数*100

#### レベル3:条件網羅（condition coverage）
判定の中の条件式の審議をどれだけ網羅したかで求められるカバレッジレベル
`C2`と表記される

コンディションカバレッジの網羅率（%）
＝実現した条件式の結果の数/すべての条件式の結果の合計数*100

