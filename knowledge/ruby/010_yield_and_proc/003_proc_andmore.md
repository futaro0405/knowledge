# Procオブジェクトについてもっと詳しく
## Procオブジェクトを実行する様々な方法
`call`以外のProcオブジェクトは幾つかある。  

```
add_proc = Proc.new { |a, b| a + b }

# callメソッドを使う
add_proc.call(10, 20) #=> 30

# yieldメソッドを使う
add_proc.yield(10, 20) #=> 30

# .()を使う
add_proc.(10, 20) #=> 30

# []を使う
add_proc.[10, 20] #=> 30

# ===を使う
add_proc === [10, 20] #=> 30
```

なぜProcオブジェクトが`===`で呼び出せるかというと、`case`文の`when`節でProcオブジェクトを使えるようにするため。  

## `&`と`to_proc`メソッド
`&`の役割はProcオブジェクトをブロックと認識させるだけではない。  
厳密には右辺のオブジェクトに対し、`to_proc`メソッドを呼び出し、その戻り値として得られたProcオブジェクトを、ブロックを利用するメソッドに与える。  
ただし、元からProcオブジェクトだった場合は`to_proc`メソッドを呼んでも自分自身が返るだけ。  

```
reverse_proc = Proc.new{ |s| s.reverse }
other_proc = reverse_proc.to_proc

# Procオブジェクトに対してto_procメソッドを呼んでも自分自身が返るだけ
reverse_proc.equal?(other_proc) #=> true
```

しかし、Procオブジェクト以外で`to_proc`メソッドを持つものがある。  
そのひとつがシンボル。シンボルを変換してできたProcオブジェクトが変わっている点は、実行時の引数の数によって実行される処理の内容が微妙に変化するところだ。  

```
split_proc = :split.to_proc
split_proc #=> #<Proc: 0 x 0000000312 f 9 a 0(&: split) (lambda)>
```

このProcオブジェクトに引数を1つ渡して実行すると、1つめの引数をレシーバにし、そのレシーバに対して元のシンボルと同じ名前のメソッドを呼び出す。  

```
# 引数が1つの場合は'a-b-c-d e'.splitと同じ
split_proc.call('a-b-c-d e')
#=> ["a-b-c-d", "e"]
```

引数を2つ渡すと1つ目の引数はレシーバのまま、2つ目の引数がシンボルで指定したメソッドの第1引数になる。  

```
# 引数が2つの場合は'a-b-c-d e'.split('-')と同じ（指定された文字で分割する）
split_proc.call('a-b-c-d e', '-')
#=> ["a","b","c","d e"]
```

同じ要領で引数を3つ渡すと3つめの引数がシンボルで指定したメソッドの第2引数になる。  

```
# 引数が3つの場合は'a-b-c-d e'.split('-', 3)と同じ（分割する個数を制限する）
split_proc.call('a-b-c-d e', '-', 3)
#=> ["a","b","c-d e"]
```

同じ要領で引数を4つ...と渡すとシンボル空Procオブジェクトを生成した場合は実行時の第1引数がメソッドのレシーバに、第2引数以降がメソッドの引数になる。  
シンボル自身はレシーバに対して呼び出すメソッドの名前になる。  

`map(&:upcase)`のような書き方は以下のような説明が付けられる。  
1. `&:upcase`はシンボルの`:upcase`に対して`to_proc`メソッドを呼び出す
1. シンボルの`:upcase`がProcオブジェクトに変換され、`map`メソッドにブロックとして渡される。
1. 上記2で作ったProcオブジェクトは`map`メソッドから配列の各要素を実行時の第1引数として受け取る。第1引数は`upcase`メソッドのレシーバとなる。つまり、配列の各要素に対して`upcase`メソッドを呼び出す。
1. `map`メソッドはProcオブジェクトの戻り値を順に新しい配列に詰め込む
1. 上記3と4のコンビネーションにより、配列の各要素が大文字に変換された新しい配列が`map`メソッドの戻り値になる。

## Procオブジェクトとクロージャ
メソッドの引数やメソッドのローカル変数は通常、メソッドの実行が終わると参照できなくなる。  
しかし、Procオブジェクト内で引数やローカル変数を参照すると、メソッドの実行が完了してもProcオブジェクトは引き続き引数やローカル変数にアクセスし続けることができる。  

```
def generate_proc(array)
  counter = 0
  # Procオブジェクトをメソッドの戻り値にする
  Proc.new do
    # ローカル変数のcounterを加算する
    counter += 10
    # メソッド引数のarrayにcounterの値を追加する
    array << counter
  end
end

values = []
sample_proc = generate_proc(values)
values #=> []

# Procオブジェクトを実行するとgenerate_procメソッドの引数だったvaluesの中身が書き換えられる
sample_proc.call
values #=> [10]

# generate_procメソッド内のローカル変数counterも加算され続ける
sample_proc.call
values #=> [10, 20]
```

一般に生成時のコンテキスト（変数情報など）を保持している関数を __クロージャ（closure、関数閉包）__ という。  
RubyのブロックやProcオブジェクトはクロージャとしてふるまう。  
